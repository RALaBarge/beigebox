<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BeigeBox â€” tap the line</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&family=Fira+Code:wght@300;400;500&display=swap');

  /* â”€â”€ Palette (matches TUI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  :root {
    --lavender:      #B48EAD;
    --lavender-dim:  #7D6080;
    --green:         #A3BE8C;
    --green-dim:     #5C7043;
    --cyan:          #88C0D0;
    --yellow:        #EBCB8B;
    --red:           #BF616A;
    --bg:            #1A1A1A;
    --bg-panel:      #212121;
    --bg-border:     #2E2E2E;
    --bg-hover:      #292929;
    --fg:            #D8DEE9;
    --fg-dim:        #6C7680;
    --fg-muted:      #4C5460;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Fira Code', 'Share Tech Mono', monospace;
    background: var(--bg);
    color: var(--fg);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    font-size: 13px;
  }

  /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #header {
    background: var(--bg-panel);
    border-bottom: 1px solid var(--lavender-dim);
    padding: 0 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 40px;
    flex-shrink: 0;
  }
  #header .logo {
    font-family: 'VT323', monospace;
    font-size: 22px;
    color: var(--lavender);
    letter-spacing: 2px;
  }
  #header .sub {
    color: var(--fg-muted);
    font-size: 11px;
    letter-spacing: 1px;
  }
  #header .status-bar {
    display: flex;
    gap: 16px;
    align-items: center;
  }
  .status-dot {
    width: 7px; height: 7px;
    border-radius: 50%;
    background: var(--fg-muted);
    display: inline-block;
    margin-right: 5px;
  }
  .status-dot.ok  { background: var(--green); box-shadow: 0 0 6px var(--green); }
  .status-dot.err { background: var(--red);   box-shadow: 0 0 6px var(--red);   }
  #clock { color: var(--fg-muted); font-size: 11px; }

  /* â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #tabs {
    background: var(--bg-panel);
    border-bottom: 1px solid var(--bg-border);
    display: flex;
    flex-shrink: 0;
  }
  .tab {
    padding: 8px 20px;
    cursor: pointer;
    color: var(--fg-dim);
    border-bottom: 2px solid transparent;
    transition: color 0.15s;
    font-size: 12px;
    letter-spacing: 0.5px;
    user-select: none;
  }
  .tab:hover { color: var(--fg); }
  .tab.active {
    color: var(--lavender);
    border-bottom-color: var(--lavender);
    font-weight: 500;
  }
  .tab .tab-key {
    color: var(--fg-muted);
    font-size: 10px;
    margin-right: 5px;
  }

  /* â”€â”€ Main content area â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #content {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .panel {
    display: none;
    flex: 1;
    overflow: hidden;
    flex-direction: column;
  }
  .panel.active { display: flex; }

  .scroll-area {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
  }
  .scroll-area::-webkit-scrollbar { width: 4px; }
  .scroll-area::-webkit-scrollbar-track { background: var(--bg); }
  .scroll-area::-webkit-scrollbar-thumb { background: var(--bg-border); border-radius: 2px; }

  /* â”€â”€ Section headers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section-header {
    color: var(--green);
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    margin: 16px 0 8px;
    border-bottom: 1px solid var(--bg-border);
    padding-bottom: 4px;
  }
  .section-header:first-child { margin-top: 0; }

  /* â”€â”€ Grid cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 8px;
    margin-bottom: 12px;
  }
  .card {
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    padding: 10px 12px;
    border-radius: 2px;
  }
  .card .card-label { color: var(--fg-muted); font-size: 10px; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 4px; }
  .card .card-value { color: var(--cyan); font-size: 18px; font-family: 'VT323', monospace; }
  .card .card-sub   { color: var(--fg-dim); font-size: 10px; margin-top: 2px; }

  /* â”€â”€ KV rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .kv-row {
    display: flex;
    gap: 8px;
    padding: 3px 0;
    border-bottom: 1px solid var(--bg-border);
    align-items: baseline;
    flex-wrap: wrap;
  }
  .kv-key   { color: var(--cyan);   min-width: 180px; font-size: 12px; cursor: default; }
  .kv-val   { color: var(--fg);     font-size: 12px; word-break: break-all; }
  /* Config tab hover tooltips */
  #cfg-tooltip {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    max-width: 280px;
    padding: 6px 10px;
    background: var(--bg-panel);
    border: 1px solid var(--cyan);
    border-radius: 4px;
    font-size: 11px;
    color: var(--fg-dim);
    line-height: 1.5;
    box-shadow: 0 2px 8px rgba(0,0,0,.45);
    display: none;
  }
  .kv-ok    { color: var(--green);  }
  .kv-warn  { color: var(--yellow); }
  .kv-err   { color: var(--red);    }
  .kv-dim   { color: var(--fg-dim); }

  /* â”€â”€ Tag badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .badge {
    display: inline-block;
    padding: 1px 6px;
    border-radius: 2px;
    font-size: 10px;
    letter-spacing: 0.5px;
  }
  .badge-ok   { background: var(--green-dim);   color: var(--green);  }
  .badge-warn { background: #3a3000;             color: var(--yellow); }
  .badge-err  { background: #3a1010;             color: var(--red);    }
  .badge-dim  { background: var(--bg-border);    color: var(--fg-dim); }
  .badge-lav  { background: #3a2a3a;             color: var(--lavender); }

  /* â”€â”€ Refresh btn â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .toolbar {
    padding: 6px 16px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--bg-border);
    display: flex;
    gap: 8px;
    align-items: center;
    flex-shrink: 0;
  }
  button, .btn {
    background: var(--bg-border);
    color: var(--fg-dim);
    border: 1px solid var(--fg-muted);
    padding: 4px 12px;
    cursor: pointer;
    font-family: inherit;
    font-size: 11px;
    letter-spacing: 0.5px;
    border-radius: 2px;
    transition: all 0.15s;
  }
  button:hover, .btn:hover {
    background: var(--bg-hover);
    color: var(--fg);
    border-color: var(--lavender);
  }
  button.primary {
    background: var(--lavender-dim);
    color: var(--bg);
    border-color: var(--lavender);
    font-weight: 500;
  }
  button.primary:hover { background: var(--lavender); }
  button:disabled { opacity: 0.4; cursor: not-allowed; }

  input, select, textarea {
    background: var(--bg);
    color: var(--fg);
    border: 1px solid var(--bg-border);
    padding: 6px 10px;
    font-family: inherit;
    font-size: 12px;
    border-radius: 2px;
    outline: none;
    transition: border-color 0.15s;
  }
  input:focus, select:focus, textarea:focus { border-color: var(--lavender-dim); }
  input::placeholder { color: var(--fg-muted); }

  .toolbar-label { color: var(--fg-dim); font-size: 11px; }
  .toolbar-spacer { flex: 1; }
  .last-updated { color: var(--fg-muted); font-size: 10px; }

  /* â”€â”€ Status subsystem table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .subsystem-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px 0;
    border-bottom: 1px solid var(--bg-border);
  }
  .subsystem-name { color: var(--fg); min-width: 160px; }
  .subsystem-detail { color: var(--fg-dim); font-size: 11px; flex: 1; }

  /* â”€â”€ Chat panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  #chat-messages::-webkit-scrollbar { width: 4px; }
  #chat-messages::-webkit-scrollbar-thumb { background: var(--bg-border); }

  .msg {
    display: flex;
    flex-direction: column;
    max-width: 85%;
    gap: 3px;
  }
  .msg.user   { align-self: flex-end; align-items: flex-end; }
  .msg.assistant { align-self: flex-start; }
  .msg .bubble {
    padding: 8px 12px;
    border-radius: 2px;
    line-height: 1.5;
    white-space: pre-wrap;
    word-break: break-word;
  }
  .msg.user .bubble {
    background: var(--lavender-dim);
    color: var(--bg);
    border-bottom-right-radius: 0;
  }
  .msg.assistant .bubble {
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    color: var(--fg);
    border-bottom-left-radius: 0;
  }
  .msg .meta {
    color: var(--fg-muted);
    font-size: 10px;
  }
  .msg.assistant .meta { color: var(--lavender-dim); }

  #chat-input-area {
    padding: 10px 16px;
    background: var(--bg-panel);
    border-top: 1px solid var(--bg-border);
    display: flex;
    gap: 8px;
    align-items: flex-end;
    flex-shrink: 0;
  }
  #chat-input {
    flex: 1;
    resize: none;
    min-height: 38px;
    max-height: 120px;
    line-height: 1.5;
    padding: 8px 10px;
  }
  #model-select { min-width: 180px; height: 38px; }

  .typing-indicator {
    display: flex; gap: 4px; align-items: center; padding: 8px 12px;
    background: var(--bg-panel); border: 1px solid var(--bg-border);
    border-radius: 2px; align-self: flex-start;
  }
  .typing-indicator span {
    width: 5px; height: 5px; border-radius: 50%;
    background: var(--lavender-dim);
    animation: blink 1.2s infinite;
  }
  .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
  .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes blink { 0%,80%,100%{opacity:0.2} 40%{opacity:1} }

  .z-hint {
    color: var(--fg-muted); font-size: 10px; padding: 2px 16px;
    background: var(--bg-panel); border-top: 1px solid var(--bg-border);
    flex-shrink: 0;
  }

  /* â”€â”€ Conversations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .conv-row {
    padding: 6px 10px;
    border-bottom: 1px solid var(--bg-border);
    cursor: pointer;
    display: flex;
    gap: 10px;
    align-items: baseline;
  }
  .conv-row:hover { background: var(--bg-hover); }
  .conv-id   { color: var(--lavender); font-size: 11px; min-width: 130px; }
  .conv-preview { color: var(--fg-dim); font-size: 11px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .conv-meta { color: var(--fg-muted); font-size: 10px; }
  .conv-score { color: var(--yellow); font-size: 10px; min-width: 50px; text-align: right; }

  /* â”€â”€ Operator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #op-log {
    flex: 1; overflow-y: auto; padding: 12px 16px; font-size: 12px; line-height: 1.6;
  }
  #op-log::-webkit-scrollbar { width: 4px; }
  #op-log::-webkit-scrollbar-thumb { background: var(--bg-border); }
  .op-query   { color: var(--cyan);    margin-bottom: 4px; }
  .op-answer  { color: var(--fg);      white-space: pre-wrap; word-break: break-word; margin-bottom: 12px; }
  .op-error   { color: var(--red);     margin-bottom: 12px; }
  .op-pending { color: var(--yellow);  font-style: italic; }
  .op-sep { border-top: 1px solid var(--bg-border); margin: 8px 0; }
  #op-input-area {
    padding: 10px 16px; background: var(--bg-panel);
    border-top: 1px solid var(--bg-border);
    display: flex; gap: 8px; flex-shrink: 0;
  }
  #op-input { flex: 1; }

  /* â”€â”€ Spinner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .spinner {
    display: inline-block; width: 10px; height: 10px;
    border: 2px solid var(--bg-border);
    border-top-color: var(--lavender);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
    vertical-align: middle;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* â”€â”€ Ï€ Vi mode toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #vi-toggle {
    position: fixed;
    bottom: 10px;
    left: 14px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    color: var(--fg-muted);
    font-size: 13px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9998;
    transition: all 0.2s;
    user-select: none;
  }
  #vi-toggle:hover { border-color: var(--lavender); color: var(--lavender); }
  #vi-toggle.active {
    background: var(--lavender-dim);
    border-color: var(--lavender);
    color: var(--bg);
    box-shadow: 0 0 8px var(--lavender-dim);
  }
  #vi-toggle .tooltip {
    display: none;
    position: absolute;
    left: 30px;
    bottom: 0;
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    color: var(--fg-dim);
    font-size: 10px;
    padding: 2px 6px;
    white-space: nowrap;
    border-radius: 2px;
    pointer-events: none;
  }
  #vi-toggle:hover .tooltip { display: block; }

  /* â”€â”€ Cost charts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .chart-wrap {
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    border-radius: 2px;
    padding: 10px 12px;
    margin-bottom: 10px;
  }
  .chart-title {
    color: var(--fg-muted);
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 8px;
  }
  canvas.bb-chart {
    display: block;
    width: 100%;
    image-rendering: pixelated;
  }
  .cost-disabled {
    color: var(--fg-muted);
    font-size: 11px;
    padding: 8px 0 4px;
  }

  /* â”€â”€ Voice / Push-to-talk â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #mic-btn {
    display: none; /* hidden until voice_enabled confirmed from server */
    background: var(--bg-panel);
    border: 1px solid var(--bg-border);
    color: var(--fg-muted);
    padding: 0 12px;
    border-radius: 2px;
    font-size: 16px;
    cursor: pointer;
    flex-shrink: 0;
    transition: all 0.15s;
    height: 100%;
    align-self: stretch;
  }
  #mic-btn:hover { border-color: var(--lavender); color: var(--lavender); }
  #mic-btn.recording {
    border-color: var(--red);
    color: var(--red);
    background: #2a1010;
    animation: mic-pulse 1s infinite;
  }
  @keyframes mic-pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(191, 97, 106, 0.4); }
    50%       { box-shadow: 0 0 0 5px rgba(191, 97, 106, 0); }
  }

  /* â”€â”€ Multi-pane chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #chat-pane-container {
    flex: 1;
    display: flex;
    gap: 4px;
    overflow: hidden;
    min-height: 0;
  }
  .chat-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--bg-border);
    border-radius: 2px;
    overflow: hidden;
    min-width: 0;
  }
  .chat-pane-header {
    background: var(--bg-panel);
    border-bottom: 1px solid var(--bg-border);
    padding: 4px 8px;
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    font-size: 11px;
  }
  .chat-pane-header select {
    font-size: 11px;
    height: 22px;
    padding: 1px 4px;
    flex: 1;
    min-width: 0;
  }
  .chat-pane-header .pane-label {
    color: var(--lavender);
    font-size: 10px;
    letter-spacing: 0.5px;
    white-space: nowrap;
  }
  .chat-pane-header button {
    padding: 1px 6px;
    font-size: 10px;
    height: 20px;
    line-height: 1;
  }
  .chat-pane-messages {
    flex: 1;
    overflow-y: auto;
    padding: 8px 10px;
    font-size: 12px;
  }
  .chat-pane-messages::-webkit-scrollbar { width: 4px; }
  .chat-pane-messages::-webkit-scrollbar-thumb { background: var(--bg-border); }

  /* â”€â”€ Chat page nav â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #chat-page-nav {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 8px;
    flex-shrink: 0;
  }
  #chat-page-nav button {
    padding: 2px 10px;
    font-size: 12px;
  }
  #chat-page-indicator {
    color: var(--fg-muted);
    font-size: 11px;
    min-width: 60px;
    text-align: center;
  }

  /* â”€â”€ Harness tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #panel-harness {
    flex-direction: column;
  }
  #harness-grid {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 4px;
    overflow: hidden;
    align-content: flex-start;
  }
  .harness-pane {
    flex: 1 1 calc(50% - 4px);
    min-width: 280px;
    max-width: calc(50% - 2px);
    min-height: 200px;
    max-height: 50%;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--bg-border);
    border-radius: 2px;
    overflow: hidden;
    box-sizing: border-box;
  }
  .harness-pane-header {
    background: var(--bg-panel);
    border-bottom: 1px solid var(--bg-border);
    padding: 4px 8px;
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    font-size: 11px;
  }
  .harness-pane-header .target-label {
    color: var(--cyan);
    font-size: 11px;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .harness-status {
    font-size: 10px;
    padding: 1px 5px;
    border-radius: 2px;
  }
  .harness-status.pending { color: var(--yellow); }
  .harness-status.done    { color: var(--green); }
  .harness-status.error   { color: var(--red); }
  .harness-pane-output {
    flex: 1;
    overflow-y: auto;
    padding: 8px 10px;
    font-size: 12px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
    color: var(--fg);
  }
  .harness-pane-output::-webkit-scrollbar { width: 4px; }
  .harness-pane-output::-webkit-scrollbar-thumb { background: var(--bg-border); }
  .harness-pane-output.thinking { color: var(--yellow); font-style: italic; }

  #harness-target-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 6px 12px;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--bg-border);
    flex-shrink: 0;
    align-items: center;
  }
  .harness-target-chip {
    background: var(--bg-border);
    border: 1px solid var(--bg-border);
    border-radius: 2px;
    padding: 2px 8px;
    font-size: 11px;
    color: var(--fg);
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: default;
  }
  .harness-target-chip .remove-chip {
    color: var(--fg-muted);
    cursor: pointer;
    font-size: 12px;
    line-height: 1;
  }
  .harness-target-chip .remove-chip:hover { color: var(--red); }

  #harness-page-nav {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 12px;
    background: var(--bg-panel);
    border-top: 1px solid var(--bg-border);
    flex-shrink: 0;
  }
  #harness-page-indicator {
    color: var(--fg-muted);
    font-size: 11px;
    min-width: 80px;
    text-align: center;
  }

  /* â”€â”€ Misc â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .empty { color: var(--fg-muted); padding: 20px; text-align: center; font-size: 12px; }
  .error-box {
    background: #2a1010; border: 1px solid var(--red);
    color: var(--red); padding: 8px 12px; border-radius: 2px; margin: 8px 0; font-size: 11px;
  }
  code {
    background: var(--bg-border); padding: 1px 5px; border-radius: 2px;
    font-family: 'Fira Code', monospace; font-size: 11px; color: var(--cyan);
  }
  .mono { font-family: 'VT323', monospace; }
  hr { border: none; border-top: 1px solid var(--bg-border); margin: 8px 0; }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  /* MOBILE RESPONSIVE DESIGN â€” 44px touch targets, single column, scrollable  */
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

  /* â”€â”€ Tablet (768pxâ€“1024px) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 1024px) {
    body { font-size: 12px; }
    
    #header {
      padding: 0 12px;
      height: 44px;
    }
    #header .logo { font-size: 18px; }
    #header .status-bar { gap: 12px; }
    
    #tabs {
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .tab {
      padding: 8px 16px;
      font-size: 11px;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 44px;
      display: flex;
      align-items: center;
    }
    
    #main-content { flex: 1; display: flex; }
    .panel { flex: 1; }
  }

  /* â”€â”€ Mobile (max 767px) â€” Single column, stacked layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 767px) {
    body { font-size: 13px; }
    
    /* Header: compact, touch-friendly */
    #header {
      padding: 0 10px;
      height: 48px;
      flex-wrap: wrap;
    }
    #header .logo { font-size: 16px; letter-spacing: 1px; }
    #header .sub { display: none; }
    #header .status-bar { gap: 8px; font-size: 10px; }
    
    /* Tabs: horizontal scroll on mobile */
    #tabs {
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      padding-bottom: 4px;
      margin-bottom: 0;
    }
    #tabs::-webkit-scrollbar {
      height: 3px;
    }
    #tabs::-webkit-scrollbar-thumb {
      background: var(--bg-border);
      border-radius: 2px;
    }
    
    .tab {
      padding: 12px 16px;
      font-size: 12px;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 44px;
      display: flex;
      align-items: center;
      border-bottom-width: 3px;
    }
    .tab:active { background: var(--bg-hover); }
    
    /* Main content: single column */
    #main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .panel {
      display: none !important;
      flex: 1;
      overflow: hidden;
    }
    .panel.active {
      display: flex !important;
      flex-direction: column;
    }
    
    /* Chat: full height, messages on top */
    #chat-panel { flex: 1; display: flex; flex-direction: column; }
    #chat-messages {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px 8px;
      gap: 8px;
    }
    
    .msg {
      max-width: 95%;
      padding: 10px 12px;
      margin: 4px 0;
      font-size: 13px;
      line-height: 1.4;
    }
    .msg.user { align-self: flex-end; max-width: 90%; }
    .msg.assistant { align-self: flex-start; }
    .msg code { font-size: 11px; }
    
    /* Chat input: responsive textarea */
    #chat-input-area {
      flex-direction: column;
      gap: 8px;
      padding: 10px 8px;
    }
    #chat-input {
      flex: 1;
      min-height: 44px;
      padding: 10px 12px;
      font-size: 13px;
      border-radius: 4px;
      border: 1px solid var(--bg-border);
    }
    #chat-input:focus {
      outline: none;
      border-color: var(--lavender-dim);
      box-shadow: 0 0 4px var(--lavender-dim);
    }
    
    .button-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .chat-button {
      padding: 10px 12px;
      min-height: 44px;
      flex: 1;
      min-width: 80px;
      font-size: 12px;
      border: 1px solid var(--bg-border);
      background: var(--bg-panel);
      color: var(--fg-dim);
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .chat-button:active {
      background: var(--bg-hover);
      color: var(--fg);
      border-color: var(--lavender-dim);
    }
    
    /* Conversations list: single column */
    #conversations-list {
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .conversation-item {
      padding: 12px 10px;
      border-bottom: 1px solid var(--bg-border);
      cursor: pointer;
      min-height: 56px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .conversation-item:active { background: var(--bg-hover); }
    .conv-title { font-size: 13px; margin-bottom: 4px; }
    .conv-preview { font-size: 11px; }
    
    /* System info: single column cards */
    #system-panel {
      padding: 10px 8px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .sys-card {
      background: var(--bg-panel);
      border: 1px solid var(--bg-border);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .sys-card-label {
      color: var(--lavender);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .sys-card-value {
      color: var(--fg);
      font-size: 13px;
      font-family: 'Fira Code', monospace;
    }
    
    /* Operator/Harness: single column */
    #operator-panel, #harness-panel {
      flex: 1;
      display: flex !important;
      flex-direction: column;
      padding: 8px;
      gap: 8px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .operator-input, #harness-input {
      width: 100%;
      min-height: 44px;
      padding: 10px 12px;
      font-size: 13px;
      border: 1px solid var(--bg-border);
      background: var(--bg-panel);
      color: var(--fg);
      border-radius: 2px;
      font-family: 'Fira Code', monospace;
      resize: vertical;
    }
    .operator-input:focus, #harness-input:focus {
      outline: none;
      border-color: var(--lavender-dim);
      box-shadow: 0 0 4px var(--lavender-dim);
    }
    
    .operator-button, #harness-run-button {
      width: 100%;
      min-height: 44px;
      padding: 10px 12px;
      font-size: 13px;
      background: var(--lavender-dim);
      color: var(--bg);
      border: none;
      border-radius: 2px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.15s;
    }
    .operator-button:active, #harness-run-button:active {
      background: var(--lavender);
      box-shadow: 0 0 8px var(--lavender-dim);
    }
    .operator-button:disabled {
      background: var(--bg-border);
      color: var(--fg-muted);
      cursor: not-allowed;
    }
    
    .operator-output, #harness-output {
      flex: 1;
      padding: 12px 10px;
      background: var(--bg-panel);
      border: 1px solid var(--bg-border);
      border-radius: 2px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      font-size: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--fg-dim);
    }
    
    /* Cost panel: cards instead of grid */
    #cost-panel { padding: 8px; }
    .chart-wrap {
      width: 100%;
      margin-bottom: 8px;
      padding: 12px 10px;
    }
    .chart-wrap canvas {
      max-height: 150px;
      margin-top: 4px;
    }
    
    /* Stats: single column */
    #stats-panel { padding: 8px; }
    .stat-card {
      background: var(--bg-panel);
      border: 1px solid var(--bg-border);
      border-radius: 4px;
      padding: 12px 10px;
      margin-bottom: 8px;
    }
    .stat-label {
      color: var(--lavender);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .stat-value {
      color: var(--green);
      font-size: 14px;
      font-family: 'Fira Code', monospace;
      font-weight: 500;
    }
    
    /* Ensemble: single column cards */
    #ensemble-panel { padding: 8px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .ensemble-result {
      background: var(--bg-panel);
      border: 1px solid var(--bg-border);
      border-radius: 4px;
      padding: 12px 10px;
      margin-bottom: 8px;
    }
    .ensemble-model {
      color: var(--lavender);
      font-size: 11px;
      font-weight: 500;
      margin-bottom: 4px;
    }
    .ensemble-text {
      color: var(--fg);
      font-size: 12px;
      line-height: 1.5;
    }
    
    /* VI toggle: always visible on mobile */
    #vi-toggle {
      bottom: 8px;
      left: 10px;
      width: 40px;
      height: 40px;
      font-size: 16px;
    }
    #vi-toggle .tooltip { left: 48px; }
    
    /* Scrollbars: wider for touch */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb {
      background: var(--bg-border);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover { background: var(--bg-hover); }
  }

  /* â”€â”€ Small mobile (max 480px) â€“ Extra tight spacing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 480px) {
    body { font-size: 12px; }
    
    #header { padding: 0 8px; height: 44px; }
    #header .logo { font-size: 14px; letter-spacing: 0.5px; }
    
    .tab { padding: 10px 12px; font-size: 11px; }
    
    .msg { padding: 8px 10px; font-size: 12px; }
    .msg.user { max-width: 85%; }
    .msg.assistant { max-width: 95%; }
    
    #chat-input-area { padding: 8px 6px; }
    #chat-input { min-height: 40px; padding: 8px 10px; }
    
    .chat-button, .operator-button, #harness-run-button {
      min-height: 40px;
      padding: 8px 10px;
      font-size: 11px;
    }
    
    .button-row { gap: 4px; }
    
    #vi-toggle { width: 36px; height: 36px; font-size: 14px; }
  }

  /* â”€â”€ Landscape orientation (any device) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (orientation: landscape) and (max-height: 600px) {
    #header { height: 40px; }
    .tab { padding: 6px 12px; min-height: 40px; }
    
    .msg { padding: 6px 8px; margin: 2px 0; }
    
    #chat-input-area { padding: 6px 4px; gap: 4px; }
    #chat-input { min-height: 32px; padding: 6px 8px; }
    
    .chat-button, .operator-button {
      min-height: 32px;
      padding: 6px 8px;
      font-size: 11px;
    }
    
    #vi-toggle { width: 32px; height: 32px; font-size: 12px; }
  }

  /* â”€â”€ Print styles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media print {
    #header, #tabs, #chat-input-area, .button-row, #vi-toggle { display: none; }
    body { background: white; color: black; }
    .msg { max-width: 100%; }
  }
</style>
</head>
<body>

<!-- â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="header">
  <div>
    <span class="logo">BeigeBox</span>
    <span class="sub" style="margin-left:12px">tap the line Â· control the carrier</span>
  </div>
  <div class="status-bar">
    <span><span class="status-dot" id="proxy-dot"></span><span id="proxy-status" style="font-size:11px;color:var(--fg-dim)">connectingâ€¦</span></span>
    <span id="clock"></span>
  </div>
</div>

<!-- â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="tabs">
  <div class="tab active" data-tab="dashboard" onclick="switchTab('dashboard')"><span class="tab-key">1</span>Dashboard</div>
  <div class="tab" data-tab="chat"      onclick="switchTab('chat')">     <span class="tab-key">2</span>Chat</div>
  <div class="tab" data-tab="convos"    onclick="switchTab('convos')">   <span class="tab-key">3</span>Conversations</div>
  <div class="tab" data-tab="tap"       onclick="switchTab('tap')">      <span class="tab-key">4</span>Tap</div>
  <div class="tab" data-tab="operator"  onclick="switchTab('operator')"> <span class="tab-key">5</span>Operator</div>
  <div class="tab" data-tab="harness"   onclick="switchTab('harness')">  <span class="tab-key">6</span>Harness</div>
  <div class="tab" data-tab="config"    onclick="switchTab('config')">   <span class="tab-key">7</span>Config</div>
</div>

<!-- â”€â”€ Content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="content">

  <!-- 1. Dashboard -->
  <div class="panel active" id="panel-dashboard">
    <div class="toolbar">
      <button onclick="loadDashboard()">â†º Refresh</button>
      <span class="toolbar-spacer"></span>
      <span class="last-updated" id="dash-updated"></span>
    </div>
    <div class="scroll-area" id="dash-body">
      <div class="empty">Loadingâ€¦</div>
    </div>
  </div>

  <!-- 2. Chat -->
  <!-- 2. Chat (multi-pane) -->
  <div class="panel" id="panel-chat">
    <div class="toolbar">
      <span class="toolbar-label">Panes:</span>
      <button onclick="addChatPane()" title="Add output pane (+)">ï¼‹</button>
      <button onclick="removeChatPane()" title="Remove last pane">ï¼</button>
      <span style="color:var(--fg-muted);font-size:10px;margin-left:4px">max 4/page Â· [ ] to page</span>
      <span class="toolbar-spacer"></span>
      <div id="chat-page-nav">
        <button onclick="chatPagePrev()" id="chat-prev-btn" title="Previous page [">â—€</button>
        <span id="chat-page-indicator">p1/1</span>
        <button onclick="chatPageNext()" id="chat-next-btn" title="Next page ]">â–¶</button>
      </div>
      <button onclick="clearAllPanes()" style="margin-left:8px">âœ• Clear all</button>
    </div>
    <div id="chat-pane-container">
      <!-- panes injected by JS -->
    </div>
    <div class="z-hint">z-commands: <code>z: search</code> <code>z: code</code> <code>z: complex</code> <code>z: help</code> â€” or target <code>@op</code> to route to Operator</div>
    <div id="chat-input-area">
      <textarea id="chat-input" placeholder="Send a messageâ€¦ (Enter=send, Shift+Enter=newline, @op prefix=operator)" rows="1"
        onkeydown="chatKeydown(event)" oninput="autoResize(this)"></textarea>
      <button id="mic-btn" title="Push to talk (click to toggle, hold to record)">ğŸ™</button>
      <button class="primary" onclick="sendChat()" id="send-btn">Send</button>
    </div>
  </div>

  <!-- 3. Conversations -->
  <div class="panel" id="panel-convos">
    <div class="toolbar">
      <input id="search-input" placeholder="Semantic searchâ€¦" style="width:300px"
        onkeydown="if(event.key==='Enter')searchConvos()">
      <button onclick="searchConvos()">Search</button>
      <span class="toolbar-spacer"></span>
      <span class="toolbar-label" id="search-status"></span>
      <select id="export-format" style="background:var(--bg2);color:var(--fg);border:1px solid var(--border);border-radius:4px;padding:3px 6px;font-size:12px">
        <option value="jsonl">JSONL</option>
        <option value="alpaca">Alpaca</option>
        <option value="sharegpt">ShareGPT</option>
      </select>
      <button onclick="exportConversations()" title="Download conversations for fine-tuning">â†“ Export</button>
    </div>
    <div class="scroll-area" id="convos-body">
      <div class="empty">Enter a search query above to search conversations semantically.</div>
    </div>
  </div>

  <!-- 4. Tap -->
  <div class="panel" id="panel-tap">
    <div class="toolbar">
      <button onclick="loadTap()">â†º Refresh</button>
      <span class="toolbar-label" style="margin-left:8px">Role:</span>
      <select id="tap-role" onchange="loadTap()" style="width:110px">
        <option value="">all</option>
        <option value="user">user</option>
        <option value="assistant">assistant</option>
        <option value="system">system</option>
        <option value="decision">decision</option>
        <option value="tool">tool</option>
      </select>
      <span class="toolbar-label" style="margin-left:8px">Direction:</span>
      <select id="tap-dir" onchange="loadTap()" style="width:110px">
        <option value="">all</option>
        <option value="inbound">inbound</option>
        <option value="outbound">outbound</option>
        <option value="internal">internal</option>
      </select>
      <span class="toolbar-label" style="margin-left:8px">Lines:</span>
      <input id="tap-n" type="number" value="50" min="10" max="500" style="width:60px" onchange="loadTap()">
      <label style="margin-left:8px;color:var(--fg-dim);font-size:11px;cursor:pointer">
        <input type="checkbox" id="tap-live" onchange="toggleTapLive()"> live
      </label>
      <span class="toolbar-spacer"></span>
      <span class="last-updated" id="tap-updated"></span>
    </div>
    <div class="scroll-area" id="tap-body" style="font-size:11px;line-height:1.6">
      <div class="empty">Loadingâ€¦</div>
    </div>
  </div>

  <!-- 6. Operator -->
  <!-- 6. Operator -->
  <div class="panel" id="panel-operator">
    <div class="toolbar">
      <span class="toolbar-label">Agent:</span>
      <select id="op-target" style="height:26px;font-size:12px;padding:2px 6px;min-width:160px">
        <option value="operator">operator (default)</option>
      </select>
      <span class="toolbar-spacer"></span>
      <span style="color:var(--fg-muted);font-size:10px">LangChain ReAct Â· tool registry</span>
      <span class="toolbar-spacer"></span>
      <button onclick="clearOp()">âœ• Clear</button>
    </div>
    <div id="op-log"></div>
    <div id="op-input-area">
      <input id="op-input" placeholder="Ask the operator anythingâ€¦"
        onkeydown="if(event.key==='Enter')runOp()">
      <button class="primary" onclick="runOp()" id="op-btn">Run</button>
    </div>
  </div>

  <!-- 7. Harness â€” parallel agent runner -->
  <div class="panel" id="panel-harness">
    <!-- Mode toggle + toolbar -->
    <div class="toolbar">
      <span class="toolbar-label">Mode:</span>
      <div style="display:flex;gap:0;border:1px solid var(--bg-border);border-radius:2px;overflow:hidden;flex-shrink:0">
        <button id="harness-mode-manual" onclick="setHarnessMode('manual')"
          style="border-radius:0;border:none;padding:2px 10px;font-size:11px;background:var(--lavender);color:#000">Manual</button>
        <button id="harness-mode-orchestrated" onclick="setHarnessMode('orchestrated')"
          style="border-radius:0;border:none;padding:2px 10px;font-size:11px;background:var(--bg-input);color:var(--fg-dim)">Orchestrated</button>
        <button id="harness-mode-ensemble" onclick="setHarnessMode('ensemble')"
          style="border-radius:0;border:none;padding:2px 10px;font-size:11px;background:var(--bg-input);color:var(--fg-dim)">Ensemble</button>
      </div>
      <span class="toolbar-spacer"></span>
      <span id="harness-manual-controls" style="display:flex;gap:6px;align-items:center">
        <span class="toolbar-label">Add target:</span>
        <select id="harness-add-select" style="height:26px;font-size:12px;padding:2px 6px;min-width:160px">
          <option value="">â€” pick agent/model â€”</option>
          <option value="operator">operator</option>
        </select>
        <button onclick="harnessAddTarget()">ï¼‹ Add</button>
        <span style="width:1px;background:var(--bg-border);height:18px;display:inline-block;margin:0 2px"></span>
        <div id="harness-page-nav" style="border:none;padding:0">
          <button onclick="harnessPagePrev()" id="harness-prev-btn" title="Previous page">â—€</button>
          <span id="harness-page-indicator">p1/1</span>
          <button onclick="harnessPageNext()" id="harness-next-btn" title="Next page">â–¶</button>
        </div>
        <button onclick="harnessRun()" class="primary" id="harness-run-btn">â–¶ Run All</button>
        <button onclick="harnessClear()">âœ• Clear</button>
      </span>
      <span id="harness-orch-controls" style="display:none;gap:6px;align-items:center">
        <span class="toolbar-label" style="color:var(--cyan)">Master model:</span>
        <select id="harness-orch-model" style="height:26px;font-size:12px;padding:2px 6px;min-width:160px">
          <option value="">â€” use operator default â€”</option>
        </select>
        <span class="toolbar-label" style="color:var(--fg-muted)">max rounds:</span>
        <input id="harness-orch-rounds" type="number" value="8" min="1" max="20"
          style="width:44px;height:26px;font-size:12px;padding:2px 4px;background:var(--bg-input);border:1px solid var(--bg-border);color:var(--fg);border-radius:2px">
        <button onclick="harnessOrchRun()" class="primary" id="harness-orch-run-btn">â–¶ Run</button>
        <button onclick="harnessOrchClear()">âœ• Clear</button>
      </span>
      <span id="harness-ensemble-controls" style="display:none;gap:6px;align-items:center">
        <span class="toolbar-label" style="color:var(--yellow)">Judge:</span>
        <select id="harness-ensemble-judge" style="height:26px;font-size:12px;padding:2px 6px;min-width:160px">
          <option value="">â€” use operator default â€”</option>
        </select>
        <button onclick="harnessEnsembleRun()" class="primary" id="harness-ensemble-run-btn">â–¶ Run Ensemble</button>
        <button onclick="harnessEnsembleClear()">âœ• Clear</button>
      </span>
    </div>

    <!-- Manual: target chips -->
    <div id="harness-target-list">
      <span style="color:var(--fg-muted);font-size:11px">No targets. Add models or agents above.</span>
    </div>

    <!-- Orchestrated: available target pool -->
    <div id="harness-orch-target-area" style="display:none;padding:4px 12px;background:var(--bg-panel);border-bottom:1px solid var(--bg-border);flex-wrap:wrap;align-items:center;gap:6px">
      <span style="color:var(--fg-muted);font-size:11px;flex-shrink:0">Available to master:</span>
      <div id="harness-orch-target-chips" style="display:flex;gap:4px;flex-wrap:wrap;flex:1"></div>
      <select id="harness-orch-add-select" style="height:22px;font-size:11px;padding:1px 4px;min-width:140px">
        <option value="">ï¼‹ add target</option>
        <option value="operator">operator</option>
      </select>
      <button onclick="harnessOrchAddTarget()" style="padding:2px 8px;font-size:11px">ï¼‹</button>
    </div>

    <!-- Ensemble: model checklist -->
    <div id="harness-ensemble-model-area" style="display:none;padding:6px 12px;background:var(--bg-panel);border-bottom:1px solid var(--bg-border)">
      <div style="font-size:11px;color:var(--fg-muted);margin-bottom:4px">Select models to compare (min 2):</div>
      <div id="harness-ensemble-model-list" style="display:flex;flex-wrap:wrap;gap:6px;max-height:80px;overflow-y:auto">
        <span style="color:var(--fg-muted);font-size:11px">Loading modelsâ€¦</span>
      </div>
    </div>

    <!-- Prompt input (shared) -->
    <div style="padding:6px 12px;background:var(--bg-panel);border-bottom:1px solid var(--bg-border);display:flex;gap:8px;flex-shrink:0">
      <textarea id="harness-prompt" rows="2"
        style="flex:1;resize:none;font-size:12px;padding:4px 8px"
        onkeydown="if(event.ctrlKey&&event.key==='Enter'){harnessMode==='manual'?harnessRun():harnessMode==='orchestrated'?harnessOrchRun():harnessEnsembleRun()}"
        placeholder="Enter goal or promptâ€¦ (Ctrl+Enter to run)"></textarea>
    </div>

    <!-- Orchestrated layout: master pane + worker grid -->
    <div id="harness-orch-layout" style="display:none;flex:1;overflow:hidden;flex-direction:column;min-height:0">
      <div id="harness-master-pane" style="flex-shrink:0;max-height:45%;overflow-y:auto;border-bottom:2px solid var(--cyan);padding:10px 14px;background:var(--bg-deep)">
        <div style="font-size:10px;color:var(--cyan);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">â—ˆ Orchestrator</div>
        <div id="harness-master-body" style="font-size:12px;line-height:1.6;color:var(--fg)">
          <span style="color:var(--fg-muted)">Waiting for goalâ€¦</span>
        </div>
      </div>
      <div id="harness-orch-grid" style="flex:1;overflow-y:auto;padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start">
        <div class="empty">Worker results will appear here.</div>
      </div>
    </div>

    <!-- Manual: 2Ã—2 pane grid -->
    <div id="harness-grid">
      <div class="empty">Add targets and enter a prompt to begin.</div>
    </div>

    <!-- Ensemble: results grid -->
    <div id="harness-ensemble-grid" style="display:none;flex:1;overflow-y:auto;padding:8px;display:flex;flex-wrap:wrap;gap:8px;align-content:flex-start">
      <div class="empty">Select models, enter a prompt, and run ensemble.</div>
    </div>
  </div>

    <!-- 8. Config -->
  <div class="panel" id="panel-config">
    <div class="toolbar">
      <button onclick="loadConfig()">â†º Refresh</button>
      <span class="toolbar-spacer"></span>
      <span class="last-updated" id="config-updated"></span>
    </div>
    <div class="scroll-area" id="config-body">
      <div class="empty">Loadingâ€¦</div>
    </div>
  </div>

</div>


<!-- Config tab tooltip -->
<div id="cfg-tooltip"></div>

<!-- â”€â”€ Vi mode toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="vi-toggle" onclick="toggleViMode()" title="">
  Ï€
  <span class="tooltip" id="vi-tooltip">vi mode: off</span>
</div>

<script>
// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BASE = '';  // same origin
let chatHistory = [];
let currentModel = localStorage.getItem('bb_model') || '';
let viModeActive = false;
let allModels = [];

// Persist and restore chat history across tab switches
function saveChatHistory() {
  try { localStorage.setItem('bb_chat_history', JSON.stringify(chatHistory)); } catch {}
}
function restoreChatHistory() {
  try {
    const saved = localStorage.getItem('bb_chat_history');
    if (saved) chatHistory = JSON.parse(saved);
  } catch {}
}

// â”€â”€ Palette themes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const THEMES = {
  default: {
    '--lavender':      '#B48EAD',
    '--lavender-dim':  '#7D6080',
    '--green':         '#A3BE8C',
    '--green-dim':     '#5C7043',
    '--cyan':          '#88C0D0',
    '--yellow':        '#EBCB8B',
    '--red':           '#BF616A',
  },
  dracula: {
    '--lavender':      '#BD93F9',
    '--lavender-dim':  '#6272A4',
    '--green':         '#50FA7B',
    '--green-dim':     '#2A7A40',
    '--cyan':          '#8BE9FD',
    '--yellow':        '#F1FA8C',
    '--red':           '#FF5555',
  },
  gruvbox: {
    '--lavender':      '#D3869B',
    '--lavender-dim':  '#8F5070',
    '--green':         '#B8BB26',
    '--green-dim':     '#636700',
    '--cyan':          '#8EC07C',
    '--yellow':        '#FABD2F',
    '--red':           '#FB4934',
  },
  nord: {
    '--lavender':      '#B48EAD',
    '--lavender-dim':  '#6B5272',
    '--green':         '#A3BE8C',
    '--green-dim':     '#4E6A35',
    '--cyan':          '#88C0D0',
    '--yellow':        '#EBCB8B',
    '--red':           '#BF616A',
  },
};

function randomPalette() {
  // Random hue, saturation 40-60%, lightness 55-75% for accents
  // Derive dim/muted variants by dropping lightness ~25%
  const hue = Math.floor(Math.random() * 360);
  const hue2 = (hue + 137) % 360;  // complementary-ish secondary
  const hue3 = (hue + 60)  % 360;  // triad for cyan
  const hue4 = (hue + 180) % 360;  // contrast for red

  const sat  = 40 + Math.floor(Math.random() * 20); // 40â€“60
  const lit  = 55 + Math.floor(Math.random() * 20); // 55â€“75
  const litD = lit - 25;                             // dim variant

  return {
    '--lavender':     `hsl(${hue},  ${sat}%, ${lit}%)`,
    '--lavender-dim': `hsl(${hue},  ${sat}%, ${litD}%)`,
    '--green':        `hsl(${hue2}, ${sat}%, ${lit}%)`,
    '--green-dim':    `hsl(${hue2}, ${sat}%, ${litD}%)`,
    '--cyan':         `hsl(${hue3}, ${sat}%, ${lit}%)`,
    '--yellow':       `hsl(45,      60%,     ${lit}%)`,
    '--red':          `hsl(${hue4}, 55%,     ${lit - 5}%)`,
  };
}

function applyPalette(name) {
  const root = document.documentElement;
  const vars = name === 'random' ? randomPalette() : (THEMES[name] || THEMES.default);
  Object.entries(vars).forEach(([prop, val]) => root.style.setProperty(prop, val));
}

// â”€â”€ Vi mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setViToggleState(active) {
  viModeActive = active;
  const btn = document.getElementById('vi-toggle');
  const tip = document.getElementById('vi-tooltip');
  btn.classList.toggle('active', active);
  if (tip) tip.textContent = `vi mode: ${active ? 'on' : 'off'}`;
}

function injectViMode() {
  if (document.getElementById('vi-script')) return;
  const s = document.createElement('script');
  s.id  = 'vi-script';
  s.src = '/web/vi.js';
  document.body.appendChild(s);
}

function removeViMode() {
  const s = document.getElementById('vi-script');
  if (s) s.remove();
  const ind = document.getElementById('vi-indicator');
  if (ind) ind.remove();
}

async function toggleViMode() {
  try {
    const d = await api('/api/v1/web-ui/toggle-vi-mode', { method: 'POST' });
    setViToggleState(d.vi_mode);
    if (d.vi_mode) injectViMode(); else removeViMode();
  } catch(e) {
    console.error('vi mode toggle failed:', e);
  }
}

// â”€â”€ Clock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateClock() {
  document.getElementById('clock').textContent = new Date().toLocaleTimeString();
}
setInterval(updateClock, 1000);
updateClock();

// â”€â”€ Tab switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(name) {
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === name));
  document.querySelectorAll('.panel').forEach(p => p.classList.toggle('active', p.id === 'panel-' + name));
  if (name === 'dashboard') loadDashboard();
  if (name === 'tap')       loadTap();
  if (name === 'config')    loadConfig();
  if (name === 'chat')      { initChatPanes(); loadModels(); }
  if (name === 'operator')  { loadOpTargets(); }
  if (name === 'harness')   { loadHarnessTargetOptions(); setHarnessMode(harnessMode); }
}

document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
  const map = {'1':'dashboard','2':'chat','3':'convos','4':'tap','5':'operator','6':'harness','7':'config'};
  if (map[e.key]) switchTab(map[e.key]);
  // [ ] to page chat panes
  if (e.key === '[') chatPagePrev();
  if (e.key === ']') chatPageNext();
  // { } to page harness
  if (e.key === '{') harnessPagePrev();
  if (e.key === '}') harnessPageNext();
});

// â”€â”€ API helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function api(path, opts={}) {
  const r = await fetch(BASE + path, opts);
  if (!r.ok) {
    let body = {};
    try { body = await r.json(); } catch {}
    const err = new Error(body.detail || body.error || body.message || `${r.status} ${r.statusText}`);
    err.status = r.status;
    err.body = body;
    throw err;
  }
  return r.json();
}

// Friendly "feature not enabled" message box
function featureDisabledMsg(featureName, configKey, extraHint) {
  return `<div style="background:var(--bg-panel);border:1px solid var(--bg-border);border-left:3px solid var(--yellow);
    padding:12px 16px;border-radius:2px;margin:8px 0">
    <div style="color:var(--yellow);font-size:12px;margin-bottom:6px">âš  ${esc(featureName)} is disabled</div>
    <div style="color:var(--fg-dim);font-size:11px;line-height:1.7">
      Enable it in the <a href="#" onclick="switchTab('config');return false" style="color:var(--cyan)">Config tab (7)</a>
      by toggling <code>${esc(configKey)}</code> and clicking Save &amp; Apply.
      ${extraHint ? `<br>${extraHint}` : ''}
    </div>
  </div>`;
}

// Generic API error box â€” distinguishes 404/disabled from real errors
function apiErrorMsg(e, featureName, configKey, extraHint) {
  if (e.status === 404 || (e.body && e.body.enabled === false)) {
    return featureDisabledMsg(featureName, configKey, extraHint);
  }
  return `<div class="error-box">${esc(featureName)}: ${esc(e.message)}</div>`;
}


function fmtTs(iso) {
  if (!iso) return '';
  try { return new Date(iso).toLocaleTimeString(); } catch { return iso; }
}

function badge(ok, yes='enabled', no='disabled') {
  return ok
    ? `<span class="badge badge-ok">${yes}</span>`
    : `<span class="badge badge-dim">${no}</span>`;
}

function kv(key, val, cls='') {
  const valCls = cls ? `kv-${cls}` : '';
  return `<div class="kv-row"><span class="kv-key">${esc(key)}</span><span class="kv-val ${valCls}">${val}</span></div>`;
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// â”€â”€ Config tab hover tooltips â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TOOLTIPS = {
  // Backend
  default_model:               'Default model sent to the backend when the frontend does not specify one.',
  // Storage
  log_conversations:           'Persist every request/response pair to SQLite for replay and search.',
  // Decision LLM
  decision_llm_enabled:        'Enable a lightweight LLM to classify requests and drive routing decisions.',
  // Tools
  tools_enabled:               'Master switch â€” enables all registered tool integrations (web search, calculator, etc.).',
  // Cost tracking
  cost_tracking_enabled:       'Track estimated token costs per request and accumulate per-model totals.',
  cost_track_openrouter:       'Include OpenRouter API requests in cost tracking.',
  cost_track_local:            'Include local Ollama requests in cost tracking (estimates only).',
  // Orchestrator
  orchestrator_enabled:        'Enable the parallel task orchestrator for multi-step agentic workflows.',
  orchestrator_max_parallel:   'Maximum number of sub-tasks the orchestrator runs simultaneously.',
  orchestrator_task_timeout:   'Seconds before an individual sub-task is abandoned.',
  orchestrator_total_timeout:  'Hard wall-clock limit (seconds) for an entire orchestration run.',
  // Conversation replay
  conversation_replay_enabled: 'Allow replaying past conversations with full context reconstruction from SQLite.',
  // Auto-summarization
  auto_summarization_enabled:  'Automatically compress long context windows when token count exceeds the budget.',
  auto_token_budget:           'Trigger summarization when the conversation exceeds this many tokens.',
  auto_summary_model:          'Model used to generate the summary. Leave blank to reuse the active model.',
  auto_keep_last:              'Number of most-recent messages preserved verbatim after summarization.',
  // Routing
  force_route:                 'Pin every session to a specific routing bucket, overriding the decision LLM.',
  // Logging
  log_level:                   'Verbosity of server-side logs: DEBUG â†’ INFO â†’ WARNING â†’ ERROR.',
  // Web UI
  web_ui_palette:              'Colour theme for this interface. Applied immediately on save.',
  web_ui_vi_mode:              'Enable vi/vim keybindings in the chat input (hjkl, i, Esc, etc.).',
  // Voice
  voice_enabled:               'Show the microphone button and enable push-to-talk via the STT service URL.',
  voice_hotkey:                'Keyboard key that triggers push-to-talk while the Chat tab is focused.',
  stt_url:                     'Speech-to-text service endpoint (OpenAI-compatible /audio/transcriptions).',
  tts_autoplay:                'Automatically play the assistant\'s response through the TTS service.',
  tts_url:                     'Text-to-speech service endpoint (OpenAI-compatible /audio/speech).',
  tts_model:                   'TTS model identifier passed to the service (e.g. tts-1, kokoro).',
  tts_speed:                   'Playback speed multiplier (0.25 â€“ 4.0). 1.0 = normal speed.',
  // Session / system context
  system_prompt_prefix:        'Text prepended to the system prompt of every proxied request at runtime.',
  system_context_enabled:      'Inject the contents of system_context.md into every request\'s system prompt.',
  // Generation parameters
  gen_force:                   'When enabled, these values override parameters set by the frontend. When disabled, they only fill in missing values.',
  gen_temperature:             'Sampling temperature (0 â€“ 2). Higher = more creative/random; lower = more deterministic.',
  gen_top_p:                   'Nucleus sampling threshold (0 â€“ 1). Limits sampling to the top-P probability mass.',
  gen_top_k:                   'Limits sampling to the top-K most likely tokens at each step.',
  gen_num_ctx:                 'Context window size in tokens passed to Ollama models.',
  gen_repeat_penalty:          'Penalty applied to repeated tokens. >1.0 discourages repetition.',
  gen_max_tokens:              'Maximum tokens to generate per response.',
  gen_seed:                    'Random seed for reproducible outputs (0 = random each time).',
};

(function initCfgTooltips() {
  const tipEl = document.getElementById('cfg-tooltip');
  if (!tipEl) return;
  document.addEventListener('mouseover', e => {
    const span = e.target.closest('[data-tip]');
    if (!span) { tipEl.style.display = 'none'; return; }
    const key  = span.dataset.tip;
    const text = TOOLTIPS[key];
    if (!text) return;
    tipEl.textContent = text;
    tipEl.style.display = 'block';
  });
  document.addEventListener('mousemove', e => {
    if (tipEl.style.display === 'none') return;
    const x = e.clientX + 14, y = e.clientY + 14;
    const rw = tipEl.offsetWidth, rh = tipEl.offsetHeight;
    tipEl.style.left = (x + rw > window.innerWidth  ? e.clientX - rw - 8 : x) + 'px';
    tipEl.style.top  = (y + rh > window.innerHeight ? e.clientY - rh - 8 : y) + 'px';
  });
  document.addEventListener('mouseout', e => {
    if (!e.target.closest('[data-tip]')) return;
    if (!e.relatedTarget || !e.relatedTarget.closest('[data-tip]')) tipEl.style.display = 'none';
  });
})();

function latencyClass(ms) {
  if (ms < 100)  return 'fast';
  if (ms < 500)  return 'medium';
  if (ms < 2000) return 'slow';
  return 'crit';
}

// â”€â”€ Health polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function pollHealth() {
  try {
    const d = await api('/beigebox/health');
    document.getElementById('proxy-dot').className = 'status-dot ok';
    document.getElementById('proxy-status').textContent = `v${d.version}`;
  } catch {
    document.getElementById('proxy-dot').className = 'status-dot err';
    document.getElementById('proxy-status').textContent = 'offline';
  }
}
pollHealth();
setInterval(pollHealth, 10000);

// â”€â”€ 1. Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadDashboard() {
  const el = document.getElementById('dash-body');
  el.innerHTML = '<div class="empty"><span class="spinner"></span> Loadingâ€¦</div>';
  try {
    const [status, stats, backends, info, costs, perf, routing] = await Promise.allSettled([
      api('/api/v1/status'),
      api('/api/v1/stats'),
      api('/api/v1/backends'),
      api('/api/v1/info'),
      api('/api/v1/costs?days=30'),
      api('/api/v1/model-performance?days=30'),
      api('/api/v1/routing-stats'),
    ]);

    let html = '';

    // â”€â”€ Stat cards â”€â”€
    const s = stats.status === 'fulfilled' ? stats.value : {};
    const convs = s.conversations || {};
    html += '<div class="card-grid">';
    html += card('Conversations', convs.total_conversations ?? 'â€”', 'stored in sqlite');
    html += card('Messages',      convs.total_messages ?? 'â€”',       'across all convos');
    html += card('Avg Length',    convs.avg_messages_per_conversation != null
      ? Number(convs.avg_messages_per_conversation).toFixed(1) : 'â€”', 'messages/convo');
    const emb = s.embeddings || {};
    html += card('Embeddings',    emb.total_embeddings ?? 'â€”', 'in chromadb');
    html += '</div>';

    // â”€â”€ Subsystems â”€â”€
    const st = status.status === 'fulfilled' ? status.value : {};
    html += '<div class="section-header">Subsystems</div>';
    if (!st.proxy) {
      // Show ghost rows so a new user understands what this section does
      const ghost = (name, detail) =>
        `<div class="subsystem-row" style="opacity:0.35">
          <span class="status-dot ok" style="display:inline-block;vertical-align:middle;margin-right:6px"></span>
          <span class="subsystem-name">${name}</span>
          <span class="subsystem-detail">${detail}</span>
        </div>`;
      html += ghost('Proxy',                'backend: http://ollama:11434');
      html += ghost('Storage Â· SQLite',     '0 messages');
      html += ghost('Storage Â· ChromaDB',   '');
      html += ghost('Decision LLM',         'disabled');
      html += ghost('Embedding Classifier', '');
      html += ghost('Tools',                'web_search, calculator, datetime, memory, â€¦');
      html += `<div style="color:var(--fg-muted);font-size:10px;padding:6px 0 2px;letter-spacing:0.5px">
        â†‘ example â€” proxy is still starting up or not reachable</div>`;
    }
    if (st.proxy) {
      html += subsystem('Proxy',              true,                   `backend: ${esc(st.proxy.backend_url || 'â€”')}`);
      html += subsystem('Storage Â· SQLite',   st.storage?.sqlite,     st.storage?.stats ? `${st.storage.stats.total_messages ?? 0} messages` : '');
      html += subsystem('Storage Â· ChromaDB', st.storage?.vector,     '');
      html += subsystem('Decision LLM',       st.routing?.decision_llm?.enabled, st.routing?.decision_llm?.model ? `model: ${esc(st.routing.decision_llm.model)}` : 'disabled');
      html += subsystem('Embedding Classifier', st.routing?.embedding_classifier?.ready, '');
      html += subsystem('Tools',              st.tools?.enabled,      st.tools?.available?.join(', ') || '');
    }

    // â”€â”€ Backends â”€â”€
    const bk = backends.status === 'fulfilled' ? backends.value : {};
    html += '<div class="section-header">Backends</div>';
    if (bk.enabled) {
      (bk.backends || []).forEach(b => {
        html += subsystem(
          `${esc(b.name)} <span class="badge badge-dim">${esc(b.provider)}</span>`,
          b.healthy,
          `priority ${b.priority} Â· ${b.url}`
        );
      });
    } else {
      const inf = info.status === 'fulfilled' ? info.value : {};
      html += subsystem('Primary Backend', true, esc(inf.backend?.url || bk.primary_backend || 'â€”'));
      html += `<div style="color:var(--fg-muted);font-size:11px;padding:4px 0">Multi-backend routing disabled (backends_enabled: false)</div>`;
    }

    // â”€â”€ Info â”€â”€
    const i = info.status === 'fulfilled' ? info.value : {};
    if (i.version) {
      html += '<div class="section-header">Info</div>';
      html += kv('version',          esc(i.version));
      html += kv('default_model',    esc(i.backend?.default_model || 'â€”'));
      html += kv('model_advertising',esc(i.model_advertising || 'â€”'));
      html += kv('server',           `${esc(i.server?.host || '0.0.0.0')}:${i.server?.port || 8000}`);
    }

    // â”€â”€ Routing stats â”€â”€
    const rd = routing.status === 'fulfilled' ? routing.value : null;
    if (rd && rd.total > 0) {
      html += '<div class="section-header">Routing Â· Session Cache</div>';
      html += '<div class="card-grid">';
      html += card('Cache Hit Rate', (rd.hit_rate * 100).toFixed(1) + '%', `${rd.total} routing decisions`);
      html += card('Cache Hits',  rd.cache_hits,  'served from session cache');
      html += card('Cache Misses', rd.cache_misses, 'required classifier / LLM');
      html += '</div>';
    }

    // â”€â”€ Cost tracking â”€â”€
    const c30 = costs.status === 'fulfilled' ? costs.value : null;
    html += '<div class="section-header">Cost Tracking Â· 30 days</div>';
    if (!c30 || !c30.enabled) {
      html += featureDisabledMsg('Cost Tracking', 'cost_tracking_enabled',
        'Tracks spend on OpenRouter API calls. Free for local Ollama models.');
    } else {
      // Summary cards
      html += '<div class="card-grid">';
      html += card('Total Spend', '$' + (c30.total || 0).toFixed(4), '30-day period');
      html += card('Daily Avg',   '$' + (c30.average_daily || 0).toFixed(4), 'per day');
      const modelCount = Object.keys(c30.by_model || {}).length;
      html += card('API Models', modelCount, 'tracked models');
      html += '</div>';
      // Charts placeholder â€” rendered after innerHTML is set
      html += '<div class="chart-wrap"><div class="chart-title">Spend by Day</div><canvas class="bb-chart" id="chart-day" height="90"></canvas></div>';
      html += '<div class="chart-wrap"><div class="chart-title">Spend by Model</div><canvas class="bb-chart" id="chart-model" height="' + Math.max(60, modelCount * 28) + '"></canvas></div>';
    }

    // â”€â”€ Model Performance â”€â”€
    const perfData = perf.status === 'fulfilled' ? perf.value : null;
    html += '<div class="section-header">Model Performance Â· 30 days</div>';
    if (!perfData || !perfData.enabled || !Object.keys(perfData.by_model || {}).length) {
      html += '<div class="cost-disabled">No latency data yet â€” recorded on non-streaming requests via the multi-backend router.</div>';
    } else {
      html += '<div class="chart-wrap"><div class="chart-title">Avg Latency by Model (ms)</div><canvas class="bb-chart" id="chart-latency" height="' + Math.max(60, Object.keys(perfData.by_model).length * 28) + '"></canvas></div>';
      html += '<div class="chart-wrap"><div class="chart-title">Tokens / sec by Model</div><canvas class="bb-chart" id="chart-tps" height="' + Math.max(60, Object.keys(perfData.by_model).length * 28) + '"></canvas></div>';
      // Stats table
      html += '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;font-size:11px">';
      html += '<tr style="color:var(--fg-muted);border-bottom:1px solid var(--bg-border)">';
      html += '<th style="text-align:left;padding:3px 8px">Model</th><th style="padding:3px 8px">Reqs</th><th style="padding:3px 8px">Avg ms</th><th style="padding:3px 8px">p50 ms</th><th style="padding:3px 8px">p95 ms</th><th style="padding:3px 8px">tok/s</th><th style="padding:3px 8px">Avg tok</th><th style="padding:3px 8px">Cost</th></tr>';
      Object.entries(perfData.by_model).forEach(([name, m]) => {
        const p95cls = m.p95_latency_ms > 5000 ? 'color:var(--red)' : m.p95_latency_ms > 2000 ? 'color:var(--yellow)' : 'color:var(--green)';
        const tps = m.avg_tokens_per_sec || 0;
        const tpscls = tps > 50 ? 'color:var(--green)' : tps > 15 ? 'color:var(--cyan)' : tps > 0 ? 'color:var(--yellow)' : 'color:var(--fg-muted)';
        html += `<tr style="border-bottom:1px solid var(--bg-border)">
          <td style="padding:3px 8px;color:var(--fg)">${esc(name)}</td>
          <td style="padding:3px 8px;color:var(--cyan);text-align:center">${m.requests}</td>
          <td style="padding:3px 8px;color:var(--fg-dim);text-align:center">${m.avg_latency_ms}</td>
          <td style="padding:3px 8px;color:var(--fg-dim);text-align:center">${m.p50_latency_ms}</td>
          <td style="padding:3px 8px;text-align:center;${p95cls}">${m.p95_latency_ms}</td>
          <td style="padding:3px 8px;text-align:center;${tpscls}">${tps > 0 ? tps.toFixed(1) : 'â€”'}</td>
          <td style="padding:3px 8px;color:var(--fg-muted);text-align:center">${m.avg_tokens}</td>
          <td style="padding:3px 8px;color:var(--fg-muted);text-align:center">$${m.total_cost_usd.toFixed(4)}</td>
        </tr>`;
      });
      html += '</table></div>';
    }

    document.getElementById('dash-updated').textContent = 'updated ' + new Date().toLocaleTimeString();
    el.innerHTML = html;

    // Render charts after DOM is ready
    if (c30?.enabled) {
      renderDayChart(c30.by_day || {});
      renderModelChart(c30.by_model || {});
    }
    if (perfData?.enabled && Object.keys(perfData.by_model || {}).length) {
      renderLatencyChart(perfData.by_model || {});
      renderTpsChart(perfData.by_model || {});
    }
  } catch(e) {
    el.innerHTML = `<div class="error-box">Failed to load dashboard: ${esc(e.message)}</div>`;
  }
}

// â”€â”€ Cost chart renderers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderDayChart(byDay) {
  const canvas = document.getElementById('chart-day');
  if (!canvas) return;

  // Sort last 30 days chronologically, fill gaps with 0
  const today = new Date();
  const labels = [];
  const values = [];
  for (let i = 29; i >= 0; i--) {
    const d = new Date(today);
    d.setDate(today.getDate() - i);
    const key = d.toISOString().slice(0, 10);
    labels.push(key.slice(5));   // MM-DD
    values.push(byDay[key] || 0);
  }

  const maxVal = Math.max(...values, 0.000001);
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.offsetWidth || canvas.parentElement.offsetWidth || 600;
  const H = parseInt(canvas.getAttribute('height')) || 90;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.height = H + 'px';

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const PAD_L = 52, PAD_R = 8, PAD_T = 8, PAD_B = 22;
  const chartW = W - PAD_L - PAD_R;
  const chartH = H - PAD_T - PAD_B;
  const barW   = Math.max(2, chartW / labels.length - 2);
  const gap    = chartW / labels.length;

  // Grid lines
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-border').trim() || '#2E2E2E';
  ctx.lineWidth = 1;
  for (let g = 0; g <= 4; g++) {
    const y = PAD_T + chartH - (g / 4) * chartH;
    ctx.beginPath(); ctx.moveTo(PAD_L, y); ctx.lineTo(PAD_L + chartW, y); ctx.stroke();
    if (g > 0) {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg-muted').trim() || '#4C5460';
      ctx.font = '9px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('$' + ((maxVal * g / 4)).toFixed(4), PAD_L - 4, y + 3);
    }
  }

  // Bars
  const barColor = getComputedStyle(document.documentElement).getPropertyValue('--lavender').trim() || '#B48EAD';
  values.forEach((v, i) => {
    const x = PAD_L + i * gap + (gap - barW) / 2;
    const barH = (v / maxVal) * chartH;
    const y = PAD_T + chartH - barH;
    ctx.fillStyle = v > 0 ? barColor : '#2E2E2E';
    ctx.fillRect(x, y, barW, barH);
  });

  // X-axis labels â€” show every 7th
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg-muted').trim() || '#4C5460';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  labels.forEach((lbl, i) => {
    if (i % 7 === 0 || i === labels.length - 1) {
      const x = PAD_L + i * gap + gap / 2;
      ctx.fillText(lbl, x, H - 4);
    }
  });
}

function renderModelChart(byModel) {
  const canvas = document.getElementById('chart-model');
  if (!canvas) return;

  const entries = Object.entries(byModel)
    .map(([name, info]) => ({ name, cost: info.cost || 0, msgs: info.messages || 0 }))
    .sort((a, b) => b.cost - a.cost)
    .slice(0, 10);

  if (!entries.length) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg-muted').trim();
    ctx.font = '11px monospace';
    ctx.fillText('No cost data recorded yet.', 10, 20);
    return;
  }

  const maxVal = Math.max(...entries.map(e => e.cost), 0.000001);
  const dpr = window.devicePixelRatio || 1;
  const W = canvas.offsetWidth || canvas.parentElement.offsetWidth || 600;
  const ROW_H = 24;
  const PAD_L = 160, PAD_R = 70, PAD_T = 6, PAD_B = 6;
  const H = PAD_T + entries.length * ROW_H + PAD_B;
  canvas.height = H;
  canvas.style.height = H + 'px';
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.height = H + 'px';

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const chartW = W - PAD_L - PAD_R;
  const barColor  = getComputedStyle(document.documentElement).getPropertyValue('--cyan').trim() || '#88C0D0';
  const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--fg-dim').trim() || '#6C7680';
  const valColor   = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() || '#D8DEE9';

  entries.forEach((e, i) => {
    const y = PAD_T + i * ROW_H;
    const barH = ROW_H - 6;
    const barW = (e.cost / maxVal) * chartW;

    // Model name label
    ctx.fillStyle = labelColor;
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';
    const shortName = e.name.length > 22 ? 'â€¦' + e.name.slice(-20) : e.name;
    ctx.fillText(shortName, PAD_L - 6, y + barH - 4);

    // Bar
    ctx.fillStyle = barColor;
    ctx.fillRect(PAD_L, y + 3, Math.max(barW, 1), barH);

    // Cost label
    ctx.fillStyle = valColor;
    ctx.textAlign = 'left';
    ctx.font = '10px monospace';
    ctx.fillText('$' + e.cost.toFixed(4) + ' Â· ' + e.msgs + 'msg', PAD_L + Math.max(barW, 1) + 6, y + barH - 4);
  });
}

function renderLatencyChart(byModel) {
  const canvas = document.getElementById('chart-latency');
  if (!canvas) return;

  const entries = Object.entries(byModel)
    .map(([name, m]) => ({ name, avg: m.avg_latency_ms, p50: m.p50_latency_ms, p95: m.p95_latency_ms }))
    .sort((a, b) => b.avg - a.avg)
    .slice(0, 10);

  if (!entries.length) return;

  const maxVal = Math.max(...entries.map(e => e.p95), 1);
  const dpr  = window.devicePixelRatio || 1;
  const W    = canvas.offsetWidth || canvas.parentElement.offsetWidth || 600;
  const ROW_H = 24;
  const PAD_L = 160, PAD_R = 80, PAD_T = 6, PAD_B = 6;
  const H = PAD_T + entries.length * ROW_H + PAD_B;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.height = H + 'px';

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const chartW = W - PAD_L - PAD_R;
  const avgColor = getComputedStyle(document.documentElement).getPropertyValue('--cyan').trim()    || '#88C0D0';
  const p95Color = getComputedStyle(document.documentElement).getPropertyValue('--yellow').trim()  || '#EBCB8B';
  const labelColor= getComputedStyle(document.documentElement).getPropertyValue('--fg-dim').trim() || '#6C7680';
  const valColor  = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()     || '#D8DEE9';

  entries.forEach((e, i) => {
    const y = PAD_T + i * ROW_H;
    const barH = ROW_H - 8;

    // Label
    ctx.fillStyle = labelColor;
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';
    const shortName = e.name.length > 22 ? 'â€¦' + e.name.slice(-20) : e.name;
    ctx.fillText(shortName, PAD_L - 6, y + barH);

    // p95 bar (background, wider)
    const p95W = (e.p95 / maxVal) * chartW;
    ctx.fillStyle = p95Color + '55';
    ctx.fillRect(PAD_L, y + 2, Math.max(p95W, 1), barH);

    // avg bar (foreground)
    const avgW = (e.avg / maxVal) * chartW;
    ctx.fillStyle = avgColor;
    ctx.fillRect(PAD_L, y + 2, Math.max(avgW, 1), barH);

    // Value label
    ctx.fillStyle = valColor;
    ctx.textAlign = 'left';
    ctx.font = '10px monospace';
    ctx.fillText(`${e.avg}ms avg  p95:${e.p95}ms`, PAD_L + Math.max(p95W, 1) + 6, y + barH);
  });
}

function renderTpsChart(byModel) {
  const canvas = document.getElementById('chart-tps');
  if (!canvas) return;

  const entries = Object.entries(byModel)
    .map(([name, m]) => ({ name, tps: m.avg_tokens_per_sec || 0 }))
    .filter(e => e.tps > 0)
    .sort((a, b) => b.tps - a.tps)
    .slice(0, 10);

  if (!entries.length) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--fg-muted').trim();
    ctx.font = '11px monospace';
    ctx.fillText('No throughput data yet (requires token_count on non-streaming responses).', 10, 20);
    return;
  }

  const maxVal = Math.max(...entries.map(e => e.tps), 1);
  const dpr    = window.devicePixelRatio || 1;
  const W      = canvas.offsetWidth || canvas.parentElement.offsetWidth || 600;
  const ROW_H  = 24;
  const PAD_L  = 160, PAD_R = 80, PAD_T = 6, PAD_B = 6;
  const H      = PAD_T + entries.length * ROW_H + PAD_B;
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  canvas.style.height = H + 'px';

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const chartW     = W - PAD_L - PAD_R;
  const barColor   = getComputedStyle(document.documentElement).getPropertyValue('--green').trim()   || '#A3BE8C';
  const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--fg-dim').trim()  || '#6C7680';
  const valColor   = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim()      || '#D8DEE9';

  entries.forEach((e, i) => {
    const y    = PAD_T + i * ROW_H;
    const barH = ROW_H - 8;
    const barW = (e.tps / maxVal) * chartW;

    ctx.fillStyle = labelColor;
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';
    const shortName = e.name.length > 22 ? 'â€¦' + e.name.slice(-20) : e.name;
    ctx.fillText(shortName, PAD_L - 6, y + barH);

    ctx.fillStyle = barColor;
    ctx.fillRect(PAD_L, y + 2, Math.max(barW, 1), barH);

    ctx.fillStyle = valColor;
    ctx.textAlign = 'left';
    ctx.font = '10px monospace';
    ctx.fillText(`${e.tps.toFixed(1)} tok/s`, PAD_L + Math.max(barW, 1) + 6, y + barH);
  });
}

function card(label, value, sub) {
  return `<div class="card"><div class="card-label">${esc(label)}</div><div class="card-value">${esc(String(value))}</div><div class="card-sub">${esc(sub)}</div></div>`;
}

function subsystem(name, ok, detail) {
  const dot = `<span class="status-dot ${ok ? 'ok' : 'err'}" style="display:inline-block;vertical-align:middle;margin-right:6px"></span>`;
  return `<div class="subsystem-row">${dot}<span class="subsystem-name">${name}</span><span class="subsystem-detail">${esc(detail)}</span></div>`;
}

// â”€â”€ 2. Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ 2. Chat (multi-pane) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pane state
const PANES_PER_PAGE = 4;
let chatPanes = [];      // [{id, target, history}]
let chatPageIdx = 0;     // 0-based page index
let chatPaneIdSeq = 0;

// Each pane has independent history. Shared user-input goes to ALL visible panes by default.
// Target can be: model id (string) or "@op" for operator.

function initChatPanes() {
  if (chatPanes.length === 0) {
    addChatPane();
  } else {
    renderChatPanes();
  }
  loadModelsForPanes();
}

function addChatPane() {
  if (chatPanes.length >= 20) return; // soft cap
  const id = ++chatPaneIdSeq;
  chatPanes.push({ id, target: currentModel || '', history: [] });
  // If the new pane would be on a new page, navigate there
  const newPage = Math.floor((chatPanes.length - 1) / PANES_PER_PAGE);
  chatPageIdx = newPage;
  renderChatPanes();
  loadModelsForPanes();
}

function removeChatPane() {
  if (chatPanes.length <= 1) return;
  chatPanes.pop();
  // Clamp page
  const maxPage = Math.max(0, Math.floor((chatPanes.length - 1) / PANES_PER_PAGE));
  if (chatPageIdx > maxPage) chatPageIdx = maxPage;
  renderChatPanes();
}

function clearAllPanes() {
  chatPanes.forEach(p => { p.history = []; });
  renderChatPanes();
}

function chatPagePrev() {
  if (chatPageIdx > 0) { chatPageIdx--; renderChatPanes(); }
}
function chatPageNext() {
  const maxPage = Math.max(0, Math.floor((chatPanes.length - 1) / PANES_PER_PAGE));
  if (chatPageIdx < maxPage) { chatPageIdx++; renderChatPanes(); }
}

function renderChatPanes() {
  const container = document.getElementById('chat-pane-container');
  container.innerHTML = '';
  const start = chatPageIdx * PANES_PER_PAGE;
  const visible = chatPanes.slice(start, start + PANES_PER_PAGE);

  visible.forEach(pane => {
    const div = document.createElement('div');
    div.className = 'chat-pane';
    div.id = `chat-pane-${pane.id}`;

    // Pane header with target selector
    div.innerHTML = `
      <div class="chat-pane-header">
        <span class="pane-label">#${pane.id}</span>
        <select class="pane-target-sel" data-pane="${pane.id}" onchange="setPaneTarget(${pane.id}, this.value)">
          <option value="">default model</option>
          <option value="@op" ${pane.target==='@op'?'selected':''}>@operator</option>
        </select>
        <button onclick="clearPane(${pane.id})" title="Clear this pane">âœ•</button>
      </div>
      <div class="chat-pane-messages" id="pane-msgs-${pane.id}"></div>`;

    container.appendChild(div);

    // Re-render history
    const msgArea = div.querySelector(`#pane-msgs-${pane.id}`);
    pane.history.forEach(m => appendMsgToPane(pane.id, m.role, m.content, m.model || '', msgArea));
  });

  // Populate model selectors
  loadModelsForPanes();
  updateChatPageNav();
}

function updateChatPageNav() {
  const totalPages = Math.max(1, Math.ceil(chatPanes.length / PANES_PER_PAGE));
  document.getElementById('chat-page-indicator').textContent = `p${chatPageIdx+1}/${totalPages}`;
  document.getElementById('chat-prev-btn').disabled = chatPageIdx === 0;
  document.getElementById('chat-next-btn').disabled = chatPageIdx >= totalPages - 1;
}

async function loadModelsForPanes() {
  let models = [];
  try {
    const d = await api('/v1/models');
    models = (d.data || d.models || []).map(m => m.id || m.name || m);
    allModels = models.map(id => ({id}));
  } catch {}

  document.querySelectorAll('.pane-target-sel').forEach(sel => {
    const paneId = parseInt(sel.dataset.pane);
    const pane = chatPanes.find(p => p.id === paneId);
    // Keep existing op option, add models
    const curVal = pane ? pane.target : '';
    sel.innerHTML = `<option value="">default model</option><option value="@op" ${curVal==='@op'?'selected':''}>@operator</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = id; opt.textContent = id;
      if (id === curVal) opt.selected = true;
      sel.appendChild(opt);
    });
  });

  // Also populate operator target dropdown
  const opSel = document.getElementById('op-target');
  if (opSel) {
    const curOp = opSel.value;
    const baseOpts = opSel.innerHTML.split('<option').filter(o => o.includes('operator')).map(o => '<option' + o).join('');
    opSel.innerHTML = `<option value="operator">operator (default)</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = 'model:' + id; opt.textContent = 'model: ' + id;
      if ('model:' + id === curOp) opt.selected = true;
      opSel.appendChild(opt);
    });
  }

  // Also populate harness add-select
  const hSel = document.getElementById('harness-add-select');
  if (hSel) {
    hSel.innerHTML = `<option value="">â€” pick agent/model â€”</option><option value="operator">operator</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = 'model:' + id; opt.textContent = id;
      hSel.appendChild(opt);
    });
  }

  // Also populate harness orch add-select and master model select
  const orchAddSel = document.getElementById('harness-orch-add-select');
  if (orchAddSel) {
    orchAddSel.innerHTML = `<option value="">ï¼‹ add target</option><option value="operator">operator</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = 'model:' + id; opt.textContent = id;
      orchAddSel.appendChild(opt);
    });
  }
  const orchModelSel = document.getElementById('harness-orch-model');
  if (orchModelSel) {
    const cur = orchModelSel.value;
    orchModelSel.innerHTML = `<option value="">â€” use operator default â€”</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = id; opt.textContent = id;
      if (id === cur) opt.selected = true;
      orchModelSel.appendChild(opt);
    });
  }

  // Also populate ensemble judge selector
  const ensJudgeSel = document.getElementById('harness-ensemble-judge');
  if (ensJudgeSel) {
    const cur = ensJudgeSel.value;
    ensJudgeSel.innerHTML = `<option value="">â€” use operator default â€”</option>`;
    models.forEach(id => {
      const opt = document.createElement('option');
      opt.value = id; opt.textContent = id;
      if (id === cur) opt.selected = true;
      ensJudgeSel.appendChild(opt);
    });
  }

  // Refresh ensemble checklist if it's currently visible
  if (harnessMode === 'ensemble') harnessEnsemblePopulateModels();
}

function setPaneTarget(paneId, val) {
  const pane = chatPanes.find(p => p.id === paneId);
  if (pane) pane.target = val;
}

function clearPane(paneId) {
  // Remove the pane entirely (keep at least 1)
  if (chatPanes.length <= 1) {
    // Just clear history if it's the last pane
    const pane = chatPanes.find(p => p.id === paneId);
    if (pane) pane.history = [];
    const area = document.getElementById(`pane-msgs-${paneId}`);
    if (area) area.innerHTML = '';
    return;
  }
  chatPanes = chatPanes.filter(p => p.id !== paneId);
  // Clamp page index
  const maxPage = Math.max(0, Math.floor((chatPanes.length - 1) / PANES_PER_PAGE));
  if (chatPageIdx > maxPage) chatPageIdx = maxPage;
  renderChatPanes();
}

function appendMsgToPane(paneId, role, text, model, container) {
  const area = container || document.getElementById(`pane-msgs-${paneId}`);
  if (!area) return null;
  const div = document.createElement('div');
  div.className = `msg ${role}`;
  div.innerHTML = `
    <div class="meta">${esc(role === 'user' ? 'you' : (model || role))} Â· ${new Date().toLocaleTimeString()}</div>
    <div class="bubble">${esc(text)}</div>`;
  area.appendChild(div);
  area.scrollTop = area.scrollHeight;
  return div;
}

async function loadModels() {
  await loadModelsForPanes();
}

function autoResize(el) {
  el.style.height = 'auto';
  el.style.height = Math.min(el.scrollHeight, 120) + 'px';
}

function chatKeydown(e) {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(); }
}

async function sendChat() {
  const input = document.getElementById('chat-input');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';
  input.style.height = 'auto';

  const sendBtn = document.getElementById('send-btn');
  sendBtn.disabled = true;

  // Check for @op prefix â€” route to operator pane(s) only
  const isOpCommand = text.startsWith('@op ') || text === '@op';
  const cleanText = isOpCommand ? text.replace(/^@op\s*/, '').trim() : text;

  // Determine which visible panes to send to
  const start = chatPageIdx * PANES_PER_PAGE;
  const visible = chatPanes.slice(start, start + PANES_PER_PAGE);

  // If @op prefix: only op-targeted panes (or all if none targeted)
  const targetPanes = isOpCommand
    ? (visible.filter(p => p.target === '@op').length > 0
        ? visible.filter(p => p.target === '@op')
        : visible)
    : visible;

  // Fan out to all target panes in parallel
  await Promise.all(targetPanes.map(pane => sendToPane(pane, cleanText, isOpCommand)));

  sendBtn.disabled = false;
  input.focus();
}

async function sendToPane(pane, text, forceOp) {
  const isOp = forceOp || pane.target === '@op';
  const area = document.getElementById(`pane-msgs-${pane.id}`);
  if (!area) return;

  // Add user message
  pane.history.push({ role: 'user', content: text });
  appendMsgToPane(pane.id, 'user', text, '', area);

  // Typing indicator
  const typingId = `typing-${pane.id}-${Date.now()}`;
  area.insertAdjacentHTML('beforeend',
    `<div class="typing-indicator" id="${typingId}"><span></span><span></span><span></span></div>`);
  area.scrollTop = area.scrollHeight;

  try {
    if (isOp) {
      // Route to operator
      const d = await api('/api/v1/operator', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: text }),
      });
      document.getElementById(typingId)?.remove();
      const answer = d.success ? d.answer : `Error: ${d.error}`;
      pane.history.push({ role: 'assistant', content: answer, model: 'operator' });
      appendMsgToPane(pane.id, 'assistant', answer, 'operator', area);
    } else {
      // Stream to model
      const model = pane.target || '';
      const body = { messages: pane.history.filter(m => m.role !== 'assistant' || m.content), stream: true };
      if (model) body.model = model;

      const resp = await fetch(BASE + '/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer beigebox' },
        body: JSON.stringify(body),
      });
      document.getElementById(typingId)?.remove();
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let fullText = '';
      let assistantDiv = null;
      let bubble = null;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value);
        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = line.slice(6).trim();
          if (data === '[DONE]') break;
          try {
            const j = JSON.parse(data);
            const delta = j.choices?.[0]?.delta?.content || '';
            if (delta) {
              fullText += delta;
              if (!assistantDiv) {
                const usedModel = j.model || model || 'assistant';
                assistantDiv = appendMsgToPane(pane.id, 'assistant', '', usedModel, area);
                bubble = assistantDiv?.querySelector('.bubble');
              }
              if (bubble) bubble.textContent = fullText;
              area.scrollTop = area.scrollHeight;
            }
          } catch {}
        }
      }
      if (fullText) {
        pane.history.push({ role: 'assistant', content: fullText, model: model || 'assistant' });
        // TTS autoplay â€” speaks the complete response after streaming finishes
        speakText(fullText);
      }
    }
  } catch(e) {
    document.getElementById(typingId)?.remove();
    appendMsgToPane(pane.id, 'assistant', `Error: ${e.message}`, 'error', area);
  }
}

// â”€â”€ Voice / Push-to-talk â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ TTS / Audio Playback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _ttsEnabled = false;
let _ttsConfig = { model: 'tts-1', voice: 'alloy', speed: 1.0 };
let _ttsAudioCtx = null;
let _ttsCurrentSource = null;

function _initAudioCtx() {
  if (!_ttsAudioCtx) {
    _ttsAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Resume if suspended (browser autoplay policy)
  if (_ttsAudioCtx.state === 'suspended') _ttsAudioCtx.resume();
  return _ttsAudioCtx;
}

async function speakText(text) {
  if (!_ttsEnabled || !text?.trim()) return;
  try {
    stopTTS();
    const payload = {
      model: _ttsConfig.model || 'tts-1',
      input: text,
      voice: _ttsConfig.voice || 'alloy',
      speed: _ttsConfig.speed || 1.0,
    };
    const resp = await fetch(BASE + '/v1/audio/speech', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer beigebox' },
      body: JSON.stringify(payload),
    });
    if (!resp.ok) { console.warn('TTS error:', resp.status); return; }
    const arrayBuf = await resp.arrayBuffer();
    const ctx = _initAudioCtx();
    const audioBuf = await ctx.decodeAudioData(arrayBuf);
    _ttsCurrentSource = ctx.createBufferSource();
    _ttsCurrentSource.buffer = audioBuf;
    _ttsCurrentSource.connect(ctx.destination);
    _ttsCurrentSource.onended = () => {
      _ttsCurrentSource = null;
      const stopBtn = document.getElementById('tts-stop-btn');
      if (stopBtn) stopBtn.style.display = 'none';
    };
    _ttsCurrentSource.start(0);
    const stopBtn = document.getElementById('tts-stop-btn');
    if (stopBtn) stopBtn.style.display = 'inline-block';
  } catch(e) {
    console.warn('TTS playback error:', e);
  }
}

function stopTTS() {
  if (_ttsCurrentSource) {
    try { _ttsCurrentSource.stop(); } catch {}
    _ttsCurrentSource = null;
  }
  const stopBtn = document.getElementById('tts-stop-btn');
  if (stopBtn) stopBtn.style.display = 'none';
}

async function testTTS() {
  const status = document.getElementById('cfg-save-status');
  // Temporarily enable for test regardless of toggle state
  const wasEnabled = _ttsEnabled;
  _ttsEnabled = true;
  // Read current form values for immediate test
  const modelEl = document.getElementById('cfg-tts_model');
  const voiceEl = document.getElementById('cfg-tts_voice');
  const speedEl = document.getElementById('cfg-tts_speed');
  const prevConfig = { ..._ttsConfig };
  if (modelEl) _ttsConfig.model = modelEl.value || 'tts-1';
  if (voiceEl) _ttsConfig.voice = voiceEl.value || 'alloy';
  if (speedEl) _ttsConfig.speed = parseFloat(speedEl.value) || 1.0;
  if (status) status.textContent = 'â–¶ Testing TTSâ€¦';
  await speakText('BeigeBox TTS test. Tap the line. Control the carrier.');
  _ttsEnabled = wasEnabled;
  _ttsConfig = prevConfig;
  if (status) setTimeout(() => { if (status.textContent.startsWith('â–¶') ) status.textContent = ''; }, 3000);
}

function updateTTSConfig(cfg) {
  _ttsEnabled = cfg?.voice?.tts_autoplay === true;
  _ttsConfig = {
    model: cfg?.voice?.tts_model || 'tts-1',
    voice: cfg?.voice?.tts_voice || 'alloy',
    speed: cfg?.voice?.tts_speed || 1.0,
  };
}
// â”€â”€ End TTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let _mediaRecorder = null;
let _audioChunks = [];
let _isRecording = false;
let _voiceEnabled = false;
let _voiceHotkey = '';

function enableVoiceUI(hotkey) {
  _voiceEnabled = true;
  _voiceHotkey = hotkey || '';
  const btn = document.getElementById('mic-btn');
  if (btn) btn.style.display = 'flex';
  if (_voiceHotkey) {
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === _voiceHotkey) {
        e.preventDefault();
        if (_isRecording) stopRecording(); else startRecording();
      }
    });
  }
}

async function startRecording() {
  if (_isRecording) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
      ? 'audio/webm;codecs=opus' : 'audio/mp4';
    _mediaRecorder = new MediaRecorder(stream, { mimeType });
    _audioChunks = [];
    _mediaRecorder.ondataavailable = e => { if (e.data.size > 0) _audioChunks.push(e.data); };
    _mediaRecorder.onstop = async () => {
      stream.getTracks().forEach(t => t.stop());
      await _transcribeAudio();
    };
    _mediaRecorder.start();
    _isRecording = true;
    const btn = document.getElementById('mic-btn');
    if (btn) { btn.classList.add('recording'); btn.title = 'Recordingâ€¦ click to stop'; }
  } catch(err) {
    console.error('Mic error:', err);
  }
}

function stopRecording() {
  if (!_isRecording || !_mediaRecorder) return;
  _mediaRecorder.stop();
  _isRecording = false;
  const btn = document.getElementById('mic-btn');
  if (btn) { btn.classList.remove('recording'); btn.title = 'Push to talk (click to toggle, hold to record)'; }
}

async function _transcribeAudio() {
  if (!_audioChunks.length) return;
  const mimeType = _audioChunks[0].type || 'audio/webm';
  const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
  const blob = new Blob(_audioChunks, { type: mimeType });
  const form = new FormData();
  form.append('file', blob, `recording.${ext}`);
  form.append('model', 'whisper-1');
  try {
    const resp = await fetch(BASE + '/v1/audio/transcriptions', { method: 'POST', body: form });
    if (!resp.ok) throw new Error(`STT ${resp.status}`);
    const data = await resp.json();
    const text = (data.text || '').trim();
    if (text) {
      const input = document.getElementById('chat-input');
      if (input) {
        input.value = text;
        autoResize(input);
        sendChat();
      }
    }
  } catch(e) {
    console.error('Transcription error:', e);
  }
}

// Wire mic button events
(function() {
  const btn = document.getElementById('mic-btn');
  if (!btn) return;
  btn.addEventListener('click', () => { if (_isRecording) stopRecording(); else startRecording(); });
  btn.addEventListener('mousedown', () => { if (!_isRecording) startRecording(); });
  btn.addEventListener('mouseup', () => { if (_isRecording) stopRecording(); });
  btn.addEventListener('mouseleave', () => { if (_isRecording) stopRecording(); });
  btn.addEventListener('touchstart', e => { e.preventDefault(); startRecording(); }, { passive: false });
  btn.addEventListener('touchend', e => { e.preventDefault(); stopRecording(); }, { passive: false });
})();
// â”€â”€ End Voice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Legacy compatibility for any code that calls appendMsg
function appendMsg(role, text, model) {
  if (chatPanes.length === 0) return null;
  const start = chatPageIdx * PANES_PER_PAGE;
  const pane = chatPanes[start] || chatPanes[0];
  return appendMsgToPane(pane.id, role, text, model);
}

// â”€â”€ 3. Conversations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exportConversations() {
  const fmt = document.getElementById('export-format')?.value || 'jsonl';
  const status = document.getElementById('search-status');
  if (status) status.textContent = `â†“ exporting ${fmt}â€¦`;
  try {
    const resp = await fetch(`${BASE}/api/v1/export?format=${encodeURIComponent(fmt)}`, {
      headers: { 'Authorization': 'Bearer beigebox' },
    });
    if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
    const blob = await resp.blob();
    const cd = resp.headers.get('Content-Disposition') || '';
    const match = cd.match(/filename="?([^"]+)"?/);
    const filename = match ? match[1] : `conversations.${fmt === 'jsonl' ? 'jsonl' : 'json'}`;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
    if (status) status.textContent = `âœ“ exported`;
    setTimeout(() => { if (status) status.textContent = ''; }, 3000);
  } catch(e) {
    if (status) status.textContent = `âœ— ${esc(e.message)}`;
  }
}

async function searchConvos() {
  const q = document.getElementById('search-input').value.trim();
  if (!q) return;
  const el = document.getElementById('convos-body');
  const status = document.getElementById('search-status');
  el.innerHTML = '<div class="empty"><span class="spinner"></span> Searchingâ€¦</div>';
  status.textContent = '';
  try {
    const d = await api(`/api/v1/search?q=${encodeURIComponent(q)}&n=10`);
    const results = d.results || [];
    status.textContent = `${results.length} conversation${results.length !== 1 ? 's' : ''}`;
    if (!results.length) {
      el.innerHTML = '<div class="empty">No results found.</div>';
      return;
    }
    let html = `<div class="section-header">Results for "${esc(q)}"</div>`;
    results.forEach(r => {
      const score = r.score != null ? (r.score * 100).toFixed(0) + '%' : '';
      const matchBadge = r.match_count > 1
        ? `<span class="badge badge-lav">${r.match_count} matches</span> `
        : '';
      const roleColor = r.role === 'user' ? 'var(--cyan)' : 'var(--yellow)';
      html += `<div class="conv-row" onclick="loadReplay('${esc(r.conversation_id || '')}')">
        <span class="conv-id">${esc((r.conversation_id || '').slice(0,16))}</span>
        <span class="conv-preview">${matchBadge}<span style="color:${roleColor};font-size:10px">${esc(r.role||'')}</span> ${esc((r.excerpt || '').slice(0,120))}</span>
        <span class="conv-meta">${fmtTs(r.timestamp)} Â· ${esc(r.model||'')}</span>
        <span class="conv-score">${esc(score)}</span>
      </div>`;
    });
    el.innerHTML = html;
  } catch(e) {
    el.innerHTML = apiErrorMsg(e, 'Semantic Search', 'log_conversations',
      'Requires ChromaDB and embeddings to be running. Check that <code>nomic-embed-text</code> is pulled in Ollama.');
  }
}

async function loadReplay(convId) {
  if (!convId) return;
  const el = document.getElementById('convos-body');
  el.insertAdjacentHTML('afterbegin',
    `<div class="section-header">Replay: ${esc(convId.slice(0,16))}
       <button onclick="forkConversation('${esc(convId)}')" style="float:right;font-size:10px;padding:2px 8px">â‘‚ Fork</button>
     </div>
     <div id="replay-body"><div class="empty"><span class="spinner"></span> Loading replayâ€¦</div></div>`);
  try {
    const d = await api(`/api/v1/conversation/${convId}/replay`);
    if (!d.enabled) {
      document.getElementById('replay-body').innerHTML =
        `<div style="color:var(--fg-muted);font-size:11px;padding:8px 0">${esc(d.message || 'Replay disabled.')}</div>`;
      return;
    }
    let html = '';
    (d.messages || []).forEach((m, i) => {
      const routeInfo = m.routing ? ` <span class="badge badge-lav">${esc(m.routing.method||'')}</span>` : '';
      const toolInfo  = m.tools?.length ? ` <span class="badge badge-ok">tools: ${esc(m.tools.join(', '))}</span>` : '';
      html += `<div class="kv-row">
        <span class="kv-key">${esc(m.role)}</span>
        <span class="kv-val">${esc((m.content||'').slice(0,120))}${routeInfo}${toolInfo}</span>
        <button onclick="forkConversation('${esc(convId)}',${i})" style="font-size:9px;padding:1px 6px;margin-left:8px;flex-shrink:0" title="Fork from this message">â‘‚</button>
      </div>`;
    });
    document.getElementById('replay-body').innerHTML = html || '<div class="empty">No messages.</div>';
  } catch(e) {
    document.getElementById('replay-body').innerHTML =
      apiErrorMsg(e, 'Conversation Replay', 'conversation_replay_enabled',
        'Reconstructs conversations with full routing context and tool calls.');
  }
}

async function forkConversation(convId, branchAt) {
  const body = {};
  if (branchAt !== undefined) body.branch_at = branchAt;
  try {
    const d = await api(`/api/v1/conversation/${convId}/fork`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    const label = branchAt !== undefined ? ` at message ${branchAt}` : ' (full copy)';
    const el = document.getElementById('replay-body') || document.getElementById('convos-body');
    el.insertAdjacentHTML('afterbegin',
      `<div class="error-box" style="background:#0a2a0a;border-color:var(--green);color:var(--green)">
         â‘‚ Forked${label} â†’ new conversation <code>${esc(d.new_conversation_id.slice(0,16))}</code>
         Â· ${d.messages_copied} messages copied
       </div>`);
  } catch(e) {
    alert('Fork failed: ' + e.message);
  }
}

// â”€â”€ 4. Tap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let _tapLiveTimer = null;

const TAP_ROLE_COLOR = {
  user:      'var(--cyan)',
  assistant: 'var(--yellow)',
  system:    'var(--fg-muted)',
  decision:  'var(--lavender)',
  tool:      'var(--green)',
  error:     'var(--red)',
};
const TAP_DIR_ARROW = { inbound: 'â”€â”€â–¶', outbound: 'â—€â”€â”€', internal: 'â”€â—â”€' };
const TAP_ROLE_ICON = { user:'â–¶', assistant:'â—€', system:'â—', decision:'âš–', tool:'âš¡', error:'âœ—' };

const TIMING_COLORS = { fast: '#a5d6a7', medium: '#fff176', slow: '#ffcc80', crit: '#ef9a9a' };

function _renderTapEntry(e) {
  const ts    = e.ts ? new Date(e.ts).toLocaleTimeString() : '?';
  const role  = e.role || '?';
  const dir   = e.dir  || '?';
  const model = e.model || '';
  const conv  = e.conv  || '';
  const content = e.content || '';
  const len   = e.len  || 0;

  const color = TAP_ROLE_COLOR[role] || 'var(--fg)';
  const arrow = TAP_DIR_ARROW[dir]   || 'â”€â”€â”€';
  const icon  = TAP_ROLE_ICON[role]  || '?';

  const modelPart = model ? ` <span style="color:var(--lavender)">[${esc(model)}]</span>` : '';
  const convPart  = conv  ? ` <span style="color:var(--fg-muted)">conv:${esc(conv.slice(0,12))}</span>` : '';
  const lenPart   = ` <span style="color:var(--fg-muted)">(${len}c)</span>`;

  // Latency badge for entries with timing data
  let latencyBadge = '';
  if (e.latency_ms != null) {
    const lc = latencyClass(e.latency_ms);
    const lcolor = TIMING_COLORS[lc];
    latencyBadge = ` <span style="font-family:'VT323',monospace;font-size:14px;color:${lcolor}">${e.latency_ms.toFixed(0)}ms</span>`;
  }

  const preview = content.length > 300 ? content.slice(0, 300) + 'â€¦' : content;
  const contentLines = esc(preview).replace(/\n/g, '<br>    ');

  // Timing breakdown bars (expandable)
  let timingHtml = '';
  if (e.timing && Object.keys(e.timing).length) {
    const total = e.latency_ms || 1;
    const uid = 'tap-timing-' + Math.random().toString(36).slice(2, 8);
    let bars = '';
    Object.entries(e.timing).forEach(([stage, ms]) => {
      const pct = Math.min(100, (ms / total) * 100);
      const lc = latencyClass(ms);
      const bcolor = TIMING_COLORS[lc];
      bars += `<div style="display:flex;gap:8px;align-items:center;padding:1px 0;font-size:10px">
        <span style="color:var(--fg-muted);min-width:100px">${esc(stage)}</span>
        <div style="flex:1;height:5px;background:var(--bg-border);border-radius:1px;overflow:hidden">
          <div style="width:${pct.toFixed(1)}%;height:100%;background:${bcolor};border-radius:1px"></div>
        </div>
        <span style="color:var(--fg-dim);min-width:70px;text-align:right">${ms.toFixed(0)}ms (${pct.toFixed(0)}%)</span>
      </div>`;
    });
    timingHtml = `<div style="margin-top:3px;padding-left:16px">
      <span onclick="const el=document.getElementById('${uid}');el.style.display=el.style.display==='none'?'block':'none'"
            style="cursor:pointer;color:var(--fg-muted);font-size:10px;user-select:none">â–¸ timing breakdown</span>
      <div id="${uid}" style="display:none;margin-top:3px">${bars}</div>
    </div>`;
  }

  return `<div style="margin-bottom:6px;border-bottom:1px solid var(--bg-border);padding-bottom:5px">
    <span style="color:var(--fg-muted)">${esc(ts)}</span>
    <span style="color:var(--fg-dim)">${esc(arrow)}</span>
    <span style="color:${color};font-weight:500">${esc(icon)} ${esc(role.toUpperCase())}</span>
    ${modelPart}${lenPart}${latencyBadge}${convPart}
    <div style="margin-top:3px;padding-left:16px;color:var(--fg-dim)">${contentLines}</div>
    ${timingHtml}
  </div>`;
}

async function loadTap() {
  const el   = document.getElementById('tap-body');
  const role = document.getElementById('tap-role').value;
  const dir  = document.getElementById('tap-dir').value;
  const n    = parseInt(document.getElementById('tap-n').value) || 50;

  // Persist filters
  try {
    localStorage.setItem('bb_tap_role', role);
    localStorage.setItem('bb_tap_dir', dir);
    localStorage.setItem('bb_tap_n', String(n));
  } catch {}

  el.innerHTML = '<div class="empty"><span class="spinner"></span> Loadingâ€¦</div>';
  try {
    let url = `/api/v1/tap?n=${n}`;
    if (role) url += `&role=${encodeURIComponent(role)}`;
    if (dir)  url += `&dir=${encodeURIComponent(dir)}`;
    const d = await api(url);

    document.getElementById('tap-updated').textContent = 'updated ' + new Date().toLocaleTimeString();

    if (!d.entries || !d.entries.length) {
      el.innerHTML = '<div class="empty">No wire entries yet. Send a request through BeigeBox.</div>';
      return;
    }

    const html = d.entries.slice().reverse().map(_renderTapEntry).join('');
    el.innerHTML = `<div style="color:var(--fg-muted);font-size:10px;padding-bottom:8px">${d.total} total Â· showing ${d.entries.length}${role ? ' Â· role=' + esc(role) : ''}${dir ? ' Â· dir=' + esc(dir) : ''}</div>` + html;
  } catch(e) {
    el.innerHTML = apiErrorMsg(e, 'Tap', 'log_conversations',
      'The tap streams all messages on the wire. Make sure <code>log_conversations</code> is enabled.');
  }
}

function toggleTapLive() {
  const live = document.getElementById('tap-live').checked;
  if (live) {
    loadTap();
    _tapLiveTimer = setInterval(loadTap, 2000);
  } else {
    clearInterval(_tapLiveTimer);
    _tapLiveTimer = null;
  }
}

// â”€â”€ 6. Operator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadOpTargets() {
  // Models are loaded by loadModelsForPanes when chat tab inits,
  // but if operator tab visited first, load them now.
  loadModelsForPanes();
}

async function runOp() {
  const input = document.getElementById('op-input');
  const query = input.value.trim();
  if (!query) return;
  input.value = '';

  const log = document.getElementById('op-log');
  const btn = document.getElementById('op-btn');
  btn.disabled = true;

  const targetSel = document.getElementById('op-target');
  const target = targetSel ? targetSel.value : 'operator';
  const isModel = target.startsWith('model:');
  const targetLabel = isModel ? target.slice(6) : 'operator';

  log.insertAdjacentHTML('beforeend',
    `<div class="op-query">â–¶ [${esc(targetLabel)}] ${esc(query)}</div>
     <div class="op-pending" id="op-pending">âŸ³ thinkingâ€¦</div>`);
  log.scrollTop = log.scrollHeight;

  try {
    if (isModel) {
      // Route to chat completions with the selected model (non-streaming for simplicity here)
      const modelId = target.slice(6);
      const d = await api('/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer beigebox' },
        body: JSON.stringify({ model: modelId, messages: [{ role: 'user', content: query }], stream: false }),
      });
      document.getElementById('op-pending')?.remove();
      const answer = d.choices?.[0]?.message?.content || JSON.stringify(d);
      log.insertAdjacentHTML('beforeend',
        `<div class="op-answer">${esc(answer)}</div><div class="op-sep"></div>`);
      speakText(answer);
    } else {
      const d = await api('/api/v1/operator', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query }),
      });
      document.getElementById('op-pending')?.remove();
      if (d.success) {
        log.insertAdjacentHTML('beforeend',
          `<div class="op-answer">${esc(d.answer)}</div><div class="op-sep"></div>`);
        speakText(d.answer);
      } else {
        log.insertAdjacentHTML('beforeend',
          `<div class="op-error">âœ— ${esc(d.error || 'unknown error')}</div><div class="op-sep"></div>`);
      }
    }
  } catch(e) {
    document.getElementById('op-pending')?.remove();
    log.insertAdjacentHTML('beforeend',
      `<div class="op-error">âœ— ${esc(e.message)}</div><div class="op-sep"></div>`);
  }

  btn.disabled = false;
  log.scrollTop = log.scrollHeight;
  input.focus();
}

function clearOp() {
  document.getElementById('op-log').innerHTML = '';
}

// â”€â”€ 7. Harness â€” parallel agent runner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HARNESS_PER_PAGE = 4;
let harnessTargets = [];   // [{key, label}]  key = "operator" | "model:llama3.2:3b"
let harnessPageIdx = 0;
let harnessRunResults = {}; // key -> {text, status}

function loadHarnessTargetOptions() {
  loadModelsForPanes(); // reuses same function to populate harness-add-select
}

function harnessAddTarget() {
  const sel = document.getElementById('harness-add-select');
  const val = sel.value;
  if (!val) return;
  const label = val === 'operator' ? 'operator' : val.startsWith('model:') ? val.slice(6) : val;
  // Avoid duplicates
  if (harnessTargets.find(t => t.key === val)) return;
  harnessTargets.push({ key: val, label });
  sel.value = '';
  renderHarnessTargetChips();
  renderHarnessGrid();
}

function harnessRemoveTarget(key) {
  harnessTargets = harnessTargets.filter(t => t.key !== key);
  delete harnessRunResults[key];
  // Clamp page
  const maxPage = Math.max(0, Math.ceil(harnessTargets.length / HARNESS_PER_PAGE) - 1);
  if (harnessPageIdx > maxPage) harnessPageIdx = maxPage;
  renderHarnessTargetChips();
  renderHarnessGrid();
}

function renderHarnessTargetChips() {
  const el = document.getElementById('harness-target-list');
  if (harnessTargets.length === 0) {
    el.innerHTML = '<span style="color:var(--fg-muted);font-size:11px">No targets. Add models or agents above.</span>';
    return;
  }
  el.innerHTML = harnessTargets.map(t => `
    <div class="harness-target-chip">
      <span>${esc(t.label)}</span>
      <span class="remove-chip" onclick="harnessRemoveTarget('${t.key.replace(/'/g,"\\'")}')">âœ•</span>
    </div>`).join('');
}

function renderHarnessGrid() {
  const grid = document.getElementById('harness-grid');
  if (harnessTargets.length === 0) {
    grid.innerHTML = '<div class="empty">Add targets and enter a prompt to begin.</div>';
    updateHarnessPageNav();
    return;
  }
  const start = harnessPageIdx * HARNESS_PER_PAGE;
  const visible = harnessTargets.slice(start, start + HARNESS_PER_PAGE);
  grid.innerHTML = '';
  visible.forEach(t => {
    const res = harnessRunResults[t.key];
    const status = res ? res.status : '';
    const text = res ? res.text : '';
    const statusHtml = status ? `<span class="harness-status ${status}">${status === 'pending' ? 'âŸ³ runningâ€¦' : status}</span>` : '';
    const pane = document.createElement('div');
    pane.className = 'harness-pane';
    pane.id = `harness-pane-${t.key.replace(/[^a-z0-9]/gi,'_')}`;
    pane.innerHTML = `
      <div class="harness-pane-header">
        <span class="target-label">${esc(t.label)}</span>
        ${statusHtml}
      </div>
      <div class="harness-pane-output${status==='pending'?' thinking':''}">${esc(text) || '<span style="color:var(--fg-muted)">waitingâ€¦</span>'}</div>`;
    grid.appendChild(pane);
  });
  updateHarnessPageNav();
}

function updateHarnessPageNav() {
  const total = Math.max(1, Math.ceil(harnessTargets.length / HARNESS_PER_PAGE));
  document.getElementById('harness-page-indicator').textContent = `p${harnessPageIdx+1}/${total}`;
  document.getElementById('harness-prev-btn').disabled = harnessPageIdx === 0;
  document.getElementById('harness-next-btn').disabled = harnessPageIdx >= total - 1;
}

function harnessPagePrev() {
  if (harnessPageIdx > 0) { harnessPageIdx--; renderHarnessGrid(); }
}
function harnessPageNext() {
  const maxPage = Math.max(0, Math.ceil(harnessTargets.length / HARNESS_PER_PAGE) - 1);
  if (harnessPageIdx < maxPage) { harnessPageIdx++; renderHarnessGrid(); }
}

async function harnessRun() {
  const prompt = document.getElementById('harness-prompt').value.trim();
  if (!prompt) return;
  if (harnessTargets.length === 0) return;

  const btn = document.getElementById('harness-run-btn');
  btn.disabled = true;

  // Mark all as pending
  harnessTargets.forEach(t => { harnessRunResults[t.key] = { text: '', status: 'pending' }; });
  renderHarnessGrid();

  // Fire all in parallel â€” each updates its own pane as it completes
  await Promise.all(harnessTargets.map(t => harnessRunTarget(t, prompt)));

  btn.disabled = false;
}

async function harnessRunTarget(target, prompt) {
  const paneId = `harness-pane-${target.key.replace(/[^a-z0-9]/gi,'_')}`;

  const updatePane = (text, status) => {
    harnessRunResults[target.key] = { text, status };
    // Only update DOM if pane is currently visible
    const pane = document.getElementById(paneId);
    if (pane) {
      const out = pane.querySelector('.harness-pane-output');
      const hdr = pane.querySelector('.harness-pane-header');
      if (out) {
        out.className = `harness-pane-output${status === 'pending' ? ' thinking' : ''}`;
        out.textContent = text || (status === 'pending' ? 'runningâ€¦' : '');
      }
      if (hdr) {
        const existing = hdr.querySelector('.harness-status');
        if (existing) existing.remove();
        if (status) {
          const sp = document.createElement('span');
          sp.className = `harness-status ${status}`;
          sp.textContent = status === 'pending' ? 'âŸ³ runningâ€¦' : status;
          hdr.appendChild(sp);
        }
      }
    }
  };

  try {
    if (target.key === 'operator') {
      updatePane('', 'pending');
      const d = await api('/api/v1/operator', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: prompt }),
      });
      const answer = d.success ? d.answer : `Error: ${d.error}`;
      updatePane(answer, d.success ? 'done' : 'error');
    } else if (target.key.startsWith('model:')) {
      const modelId = target.key.slice(6);
      updatePane('', 'pending');
      // Stream the response, updating pane incrementally
      const resp = await fetch(BASE + '/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer beigebox' },
        body: JSON.stringify({
          model: modelId,
          messages: [{ role: 'user', content: prompt }],
          stream: true,
        }),
      });
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let fullText = '';
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value);
        for (const line of chunk.split('\n')) {
          if (!line.startsWith('data: ')) continue;
          const data = line.slice(6).trim();
          if (data === '[DONE]') break;
          try {
            const j = JSON.parse(data);
            const delta = j.choices?.[0]?.delta?.content || '';
            if (delta) {
              fullText += delta;
              updatePane(fullText, 'pending');
            }
          } catch {}
        }
      }
      updatePane(fullText, 'done');
    }
  } catch(e) {
    updatePane(`Error: ${e.message}`, 'error');
  }
}

function harnessClear() {
  harnessRunResults = {};
  renderHarnessGrid();
}

// â”€â”€ Harness mode switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let harnessMode = 'manual'; // 'manual' | 'orchestrated'
let harnessOrchTargets = []; // targets the master can use: [{key, label}]

function setHarnessMode(mode) {
  harnessMode = mode;
  const isMan  = mode === 'manual';
  const isOrch = mode === 'orchestrated';
  const isEns  = mode === 'ensemble';

  // â”€â”€ Mode button styles â”€â”€
  const manBtn  = document.getElementById('harness-mode-manual');
  const orchBtn = document.getElementById('harness-mode-orchestrated');
  const ensBtn  = document.getElementById('harness-mode-ensemble');
  if (manBtn)  { manBtn.style.background  = isMan  ? 'var(--lavender)' : 'var(--bg-input)'; manBtn.style.color  = isMan  ? '#000' : 'var(--fg-dim)'; }
  if (orchBtn) { orchBtn.style.background = isOrch ? 'var(--cyan)'     : 'var(--bg-input)'; orchBtn.style.color = isOrch ? '#000' : 'var(--fg-dim)'; }
  if (ensBtn)  { ensBtn.style.background  = isEns  ? 'var(--yellow)'   : 'var(--bg-input)'; ensBtn.style.color  = isEns  ? '#000' : 'var(--fg-dim)'; }

  // â”€â”€ Toolbar control bars â”€â”€
  const manControls = document.getElementById('harness-manual-controls');
  const orchControls = document.getElementById('harness-orch-controls');
  const ensControls  = document.getElementById('harness-ensemble-controls');
  if (manControls)  manControls.style.display  = isMan  ? 'flex' : 'none';
  if (orchControls) orchControls.style.display  = isOrch ? 'flex' : 'none';
  if (ensControls)  ensControls.style.display   = isEns  ? 'flex' : 'none';

  // â”€â”€ Target / model areas â”€â”€
  const manTargets      = document.getElementById('harness-target-list');
  const orchTargetArea  = document.getElementById('harness-orch-target-area');
  const ensModelArea    = document.getElementById('harness-ensemble-model-area');
  if (manTargets)     manTargets.style.display    = isMan  ? ''     : 'none';
  if (orchTargetArea) orchTargetArea.style.display = isOrch ? 'flex' : 'none';
  if (ensModelArea)   ensModelArea.style.display   = isEns  ? ''     : 'none';

  // â”€â”€ Result grids â”€â”€
  const manGrid   = document.getElementById('harness-grid');
  const orchLayout = document.getElementById('harness-orch-layout');
  const ensGrid    = document.getElementById('harness-ensemble-grid');
  if (manGrid)    manGrid.style.display    = isMan  ? ''     : 'none';
  if (orchLayout) orchLayout.style.display = isOrch ? 'flex' : 'none';
  if (ensGrid)    ensGrid.style.display    = isEns  ? 'flex' : 'none';

  // â”€â”€ Prompt placeholder â”€â”€
  const ta = document.getElementById('harness-prompt');
  if (ta) ta.placeholder =
    isOrch ? 'Describe the goalâ€¦ the orchestrator will plan, delegate, and iterate. (Ctrl+Enter to run)' :
    isEns  ? 'Prompt to compare across all selected modelsâ€¦ (Ctrl+Enter to run)' :
             'Prompt to send to all targetsâ€¦ (Ctrl+Enter to run)';

  // â”€â”€ Seed orchestrated target pool on first switch â”€â”€
  if (isOrch && harnessOrchTargets.length === 0) {
    ['operator', ...harnessTargets.map(t => t.key)].forEach(key => {
      if (!harnessOrchTargets.find(t => t.key === key)) {
        const label = key === 'operator' ? 'operator' : key.startsWith('model:') ? key.slice(6) : key;
        harnessOrchTargets.push({ key, label });
      }
    });
    renderOrchTargetChips();
  }

  // â”€â”€ Populate ensemble model checklist on first switch â”€â”€
  if (isEns) harnessEnsemblePopulateModels();
}

// â”€â”€ Orchestrated target pool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function harnessOrchAddTarget() {
  const sel = document.getElementById('harness-orch-add-select');
  const val = sel.value;
  if (!val) return;
  if (harnessOrchTargets.find(t => t.key === val)) { sel.value = ''; return; }
  const label = val === 'operator' ? 'operator' : val.startsWith('model:') ? val.slice(6) : val;
  harnessOrchTargets.push({ key: val, label });
  sel.value = '';
  renderOrchTargetChips();
}

function harnessOrchRemoveTarget(key) {
  harnessOrchTargets = harnessOrchTargets.filter(t => t.key !== key);
  renderOrchTargetChips();
}

function renderOrchTargetChips() {
  const el = document.getElementById('harness-orch-target-chips');
  if (!el) return;
  el.innerHTML = harnessOrchTargets.map(t =>
    `<div class="harness-target-chip" style="font-size:11px;padding:1px 6px">
      <span>${esc(t.label)}</span>
      <span class="remove-chip" onclick="harnessOrchRemoveTarget('${t.key.replace(/'/g,"\\'")}')">âœ•</span>
    </div>`
  ).join('') || '<span style="color:var(--fg-muted);font-size:11px">No targets set â€” master will use all available models.</span>';
}

// â”€â”€ Orchestrated run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let _orchAbort = null; // AbortController for cancelling a run

function harnessOrchClear() {
  if (_orchAbort) { _orchAbort.abort(); _orchAbort = null; }
  const master = document.getElementById('harness-master-body');
  if (master) master.innerHTML = '<span style="color:var(--fg-muted)">Waiting for goalâ€¦</span>';
  const grid = document.getElementById('harness-orch-grid');
  if (grid) grid.innerHTML = '<div class="empty">Worker results will appear here.</div>';
  const btn = document.getElementById('harness-orch-run-btn');
  if (btn) { btn.disabled = false; btn.textContent = 'â–¶ Run'; }
}

async function harnessOrchRun() {
  const goal = document.getElementById('harness-prompt').value.trim();
  if (!goal) return;

  const btn = document.getElementById('harness-orch-run-btn');
  const masterBody = document.getElementById('harness-master-body');
  const orchGrid = document.getElementById('harness-orch-grid');

  btn.disabled = true;
  btn.textContent = 'âŸ³ Runningâ€¦';
  masterBody.innerHTML = `<div style="color:var(--cyan);font-size:11px">Goal: ${esc(goal)}</div><div class="empty" style="margin-top:8px"><span class="spinner"></span> Planningâ€¦</div>`;
  orchGrid.innerHTML = '';

  _orchAbort = new AbortController();

  const targets = harnessOrchTargets.length > 0
    ? harnessOrchTargets.map(t => t.key)
    : ['operator'];
  const modelOverride = document.getElementById('harness-orch-model')?.value || null;
  const maxRounds = parseInt(document.getElementById('harness-orch-rounds')?.value || '8');

  // Track worker panes by target+round key
  const workerPanes = {}; // "round-target" -> dom element

  function getOrCreateWorkerPane(round, target, prompt, rationale) {
    const paneKey = `r${round}-${target.replace(/[^a-z0-9]/gi,'_')}`;
    if (workerPanes[paneKey]) return workerPanes[paneKey];
    const el = document.createElement('div');
    el.className = 'harness-pane';
    el.id = `orch-pane-${paneKey}`;
    el.style.minWidth = '240px';
    el.style.flex = '1 1 240px';
    el.innerHTML = `
      <div class="harness-pane-header">
        <span class="target-label">${esc(target)}</span>
        <span style="font-size:9px;color:var(--fg-muted)">round ${round}</span>
        <span class="harness-status pending" id="orch-status-${paneKey}">âŸ³ runningâ€¦</span>
      </div>
      <div style="font-size:10px;color:var(--fg-muted);padding:2px 0 6px;border-bottom:1px solid var(--bg-border);margin-bottom:4px">${esc(prompt.slice(0,120))}${prompt.length>120?'â€¦':''}</div>
      <div class="harness-pane-output thinking" id="orch-output-${paneKey}">waitingâ€¦</div>`;
    orchGrid.appendChild(el);
    workerPanes[paneKey] = el;
    return el;
  }

  function updateWorkerPane(round, target, content, status) {
    const paneKey = `r${round}-${target.replace(/[^a-z0-9]/gi,'_')}`;
    const outputEl = document.getElementById(`orch-output-${paneKey}`);
    const statusEl = document.getElementById(`orch-status-${paneKey}`);
    if (outputEl) {
      outputEl.className = `harness-pane-output${status === 'pending' ? ' thinking' : ''}`;
      outputEl.textContent = content;
    }
    if (statusEl) {
      statusEl.className = `harness-status ${status}`;
      statusEl.textContent = status === 'pending' ? 'âŸ³ runningâ€¦' : status;
    }
  }

  // Master pane rendering helpers
  let masterLog = [`<div style="color:var(--cyan);font-size:11px;margin-bottom:8px">Goal: ${esc(goal)}</div>`];
  function appendMaster(html) {
    masterLog.push(html);
    masterBody.innerHTML = masterLog.join('');
    masterBody.scrollTop = masterBody.scrollHeight;
  }

  try {
    const resp = await fetch(BASE + '/api/v1/harness/orchestrate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: goal, targets, model: modelOverride, max_rounds: maxRounds }),
      signal: _orchAbort.signal,
    });

    if (!resp.ok) {
      const err = await resp.json().catch(() => ({}));
      appendMaster(`<div class="error-box">Error: ${esc(err.error || resp.statusText)}</div>`);
      btn.disabled = false; btn.textContent = 'â–¶ Run';
      return;
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      const lines = buf.split('\n');
      buf = lines.pop(); // keep incomplete line

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const raw = line.slice(6).trim();
        if (raw === '[DONE]') break;

        let ev;
        try { ev = JSON.parse(raw); } catch { continue; }

        switch (ev.type) {
          case 'start':
            appendMaster(`<div style="color:var(--fg-muted);font-size:11px">Model: ${esc(ev.model)} Â· Targets: ${ev.targets.map(esc).join(', ')}</div>`);
            break;

          case 'plan': {
            const taskList = (ev.tasks || []).map(t =>
              `<div style="padding:2px 0 2px 8px;border-left:2px solid var(--lavender)">
                <span style="color:var(--lavender)">${esc(t.target)}</span>
                <span style="color:var(--fg-muted);font-size:10px;margin-left:6px">${esc(t.rationale||'')}</span><br>
                <span style="font-size:11px">${esc(t.prompt.slice(0,150))}${t.prompt.length>150?'â€¦':''}</span>
              </div>`).join('');
            appendMaster(`
              <div style="margin-top:8px;border-top:1px solid var(--bg-border);padding-top:8px">
                <span style="color:var(--yellow);font-size:10px">ROUND ${ev.round} â€” PLAN</span>
                <div style="font-size:11px;color:var(--fg-dim);margin:4px 0">${esc(ev.reasoning||'')}</div>
                ${taskList}
              </div>`);
            // Pre-create worker panes
            (ev.tasks || []).forEach(t => getOrCreateWorkerPane(ev.round, t.target, t.prompt, t.rationale||''));
            break;
          }

          case 'result': {
            const statusClass = ev.status === 'done' ? 'done' : ev.status === 'error' ? 'error' : 'pending';
            updateWorkerPane(ev.round, ev.target, ev.content, statusClass);
            break;
          }

          case 'evaluate':
            appendMaster(`
              <div style="margin-top:6px;padding:4px 8px;background:var(--bg-deep);border-left:2px solid ${ev.action==='finish'?'var(--green)':'var(--yellow)'}">
                <span style="font-size:10px;color:${ev.action==='finish'?'var(--green)':'var(--yellow)'}">${ev.action === 'finish' ? 'âœ“ SUFFICIENT' : 'â†» NEEDS MORE'}</span>
                <div style="font-size:11px;color:var(--fg-dim);margin-top:2px">${esc(ev.assessment||'')}</div>
              </div>`);
            break;

          case 'finish':
            appendMaster(`
              <div style="margin-top:12px;border-top:2px solid var(--green);padding-top:10px">
                <span style="color:var(--green);font-size:11px">âœ“ DONE${ev.capped?' (round cap)':''} Â· ${ev.rounds} round${ev.rounds!==1?'s':''}</span>
                <div style="margin-top:8px;font-size:12px;line-height:1.6;white-space:pre-wrap">${esc(ev.answer||'')}</div>
              </div>`);
            btn.disabled = false; btn.textContent = 'â–¶ Run';
            break;

          case 'error':
            appendMaster(`<div class="error-box" style="margin-top:8px">${esc(ev.message||'Unknown error')}</div>`);
            btn.disabled = false; btn.textContent = 'â–¶ Run';
            break;
        }
      }
    }
  } catch(e) {
    if (e.name !== 'AbortError') {
      appendMaster(`<div class="error-box">${esc(e.message)}</div>`);
    }
    btn.disabled = false; btn.textContent = 'â–¶ Run';
  }
}

// â”€â”€ 7b. Ensemble Voting (Harness mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ensembleSelectedModels = new Set();

function harnessEnsemblePopulateModels() {
  const listEl = document.getElementById('harness-ensemble-model-list');
  const judgeEl = document.getElementById('harness-ensemble-judge');
  if (!listEl || !judgeEl) return;

  listEl.innerHTML = '';
  judgeEl.innerHTML = '<option value="">â€” use operator default â€”</option>';

  (allModels || []).forEach(m => {
    // Checkbox chip
    const chip = document.createElement('label');
    chip.style.cssText = 'display:flex;align-items:center;gap:4px;padding:2px 8px;border:1px solid var(--bg-border);border-radius:3px;cursor:pointer;font-size:11px;background:var(--bg-input);white-space:nowrap';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.value = m.id;
    cb.checked = ensembleSelectedModels.has(m.id);
    cb.onchange = () => {
      if (cb.checked) ensembleSelectedModels.add(m.id);
      else ensembleSelectedModels.delete(m.id);
      chip.style.borderColor = cb.checked ? 'var(--yellow)' : 'var(--bg-border)';
    };
    if (cb.checked) chip.style.borderColor = 'var(--yellow)';
    chip.appendChild(cb);
    chip.appendChild(document.createTextNode(' ' + m.id));
    listEl.appendChild(chip);

    // Judge selector
    const opt = document.createElement('option');
    opt.value = m.id;
    opt.textContent = m.id;
    judgeEl.appendChild(opt);
  });
}

async function harnessEnsembleRun() {
  const prompt = document.getElementById('harness-prompt').value.trim();
  if (!prompt) { alert('Enter a prompt first'); return; }
  if (ensembleSelectedModels.size < 2) { alert('Select at least 2 models'); return; }

  const judgeModel = document.getElementById('harness-ensemble-judge').value;
  const grid = document.getElementById('harness-ensemble-grid');
  if (!grid) return;

  const models = [...ensembleSelectedModels];
  grid.innerHTML = `<div style="padding:12px;color:var(--fg-muted);font-size:12px">â³ Querying ${models.length} modelsâ€¦</div>`;

  const runBtn = document.getElementById('harness-ensemble-run-btn');
  if (runBtn) { runBtn.disabled = true; runBtn.textContent = 'â³ Runningâ€¦'; }

  // Create placeholder cards for each model
  const cards = {};
  grid.innerHTML = '';
  models.forEach(model => {
    const card = document.createElement('div');
    card.style.cssText = 'flex:1;min-width:260px;max-width:460px;border:1px solid var(--bg-border);border-radius:3px;padding:10px;background:var(--bg-panel)';
    card.innerHTML = `<div style="font-size:10px;color:var(--fg-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">${esc(model)}</div>
      <div class="card-body" style="font-size:12px;line-height:1.6;color:var(--fg-dim)">waitingâ€¦</div>`;
    grid.appendChild(card);
    cards[model] = card;
  });

  // Winner banner placeholder
  const banner = document.createElement('div');
  banner.style.cssText = 'width:100%;padding:10px 14px;border:1px solid var(--bg-border);border-radius:3px;background:var(--bg-deep);font-size:12px';
  banner.innerHTML = '<span style="color:var(--fg-muted)">Waiting for judgeâ€¦</span>';
  grid.insertBefore(banner, grid.firstChild);

  try {
    const resp = await fetch('/api/v1/ensemble', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ models, judge_model: judgeModel || undefined, prompt }),
    });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      const lines = buf.split('\n');
      buf = lines.pop();
      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        try {
          const ev = JSON.parse(line.slice(6));
          if (ev.type === 'result' && cards[ev.model]) {
            cards[ev.model].querySelector('.card-body').style.color = 'var(--fg)';
            cards[ev.model].querySelector('.card-body').textContent = ev.response;
            cards[ev.model].querySelector('div').style.color = 'var(--lavender)';
          } else if (ev.type === 'finish') {
            banner.innerHTML = `<div style="color:var(--green);font-weight:bold;margin-bottom:4px">ğŸ† Winner: ${esc(ev.winner)}</div>
              <div style="font-size:11px;color:var(--fg-dim);white-space:pre-wrap">${esc(ev.verdict || '')}</div>`;
            if (cards[ev.winner]) {
              cards[ev.winner].style.borderColor = 'var(--green)';
              cards[ev.winner].style.borderWidth = '2px';
            }
          } else if (ev.type === 'error') {
            banner.innerHTML = `<div class="error-box">Error: ${esc(ev.message)}</div>`;
          }
        } catch {}
      }
    }
  } catch (e) {
    banner.innerHTML = `<div class="error-box">Error: ${esc(e.message)}</div>`;
  } finally {
    if (runBtn) { runBtn.disabled = false; runBtn.textContent = 'â–¶ Run Ensemble'; }
  }
}

function harnessEnsembleClear() {
  ensembleSelectedModels.clear();
  const grid = document.getElementById('harness-ensemble-grid');
  if (grid) grid.innerHTML = '<div class="empty">Select models, enter a prompt, and run ensemble.</div>';
  harnessEnsemblePopulateModels();
}
function cfgInput(id, label, value, type='text') {
  return `<div class="kv-row" style="gap:12px;align-items:center">
    <span class="kv-key" style="min-width:160px" data-tip="${id}">${esc(label)}</span>
    <input id="cfg-${id}" type="${type}" value="${esc(String(value ?? ''))}"
      style="flex:1;min-width:0;max-width:360px;height:26px;padding:2px 6px;font-size:12px">
  </div>`;
}
function cfgToggle(id, label, checked) {
  return `<div class="kv-row" style="gap:12px;align-items:center">
    <span class="kv-key" style="min-width:160px" data-tip="${id}">${esc(label)}</span>
    <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
      <input id="cfg-${id}" type="checkbox" ${checked ? 'checked' : ''}
        style="width:14px;height:14px;cursor:pointer">
      <span id="cfg-${id}-lbl" style="font-size:11px;color:var(--fg-dim)">${checked ? 'enabled' : 'disabled'}</span>
    </label>
  </div>`;
}
function cfgSelect(id, label, value, options) {
  const opts = options.map(o => `<option value="${esc(o)}" ${o===value?'selected':''}>${esc(o)}</option>`).join('');
  return `<div class="kv-row" style="gap:12px;align-items:center">
    <span class="kv-key" style="min-width:160px" data-tip="${id}">${esc(label)}</span>
    <select id="cfg-${id}" style="height:26px;padding:2px 6px;font-size:12px;min-width:160px">${opts}</select>
  </div>`;
}

async function loadConfig() {
  const el = document.getElementById('config-body');
  el.innerHTML = '<div class="empty"><span class="spinner"></span> Loadingâ€¦</div>';
  try {
    const [cfg, tools] = await Promise.allSettled([
      api('/api/v1/config'),
      api('/api/v1/tools'),
    ]);

    const c = cfg.status === 'fulfilled' ? cfg.value : {};
    const t = tools.status === 'fulfilled' ? tools.value : {};

    let html = '';

    // â”€â”€ Save bar (top) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += `<div style="position:sticky;top:0;z-index:10;background:var(--bg-panel);padding:8px 0 10px;border-bottom:1px solid var(--bg-border);margin-bottom:12px;display:flex;gap:8px;align-items:center">
      <button class="primary" onclick="saveConfig()">ğŸ’¾ Save &amp; Apply</button>
      <span id="cfg-save-status" style="font-size:11px;color:var(--fg-dim)"></span>
    </div>`;

    // â”€â”€ Backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header">Backend</div>';
    html += kv('backend url', esc(c.backend?.url || 'â€”'));
    html += kv('embedding model', esc(c.embedding?.model || 'â€”'));
    html += kv('embedding url', esc(c.embedding?.backend_url || 'â€”'));
    html += cfgInput('default_model', 'Default model', c.backend?.default_model || '');
    html += kv('timeout', `${c.backend?.timeout || 120}s`);

    // â”€â”€ Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Server</div>';
    html += kv('host', esc(c.server?.host || '0.0.0.0'));
    html += kv('port', String(c.server?.port || 8000));

    // â”€â”€ Storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Storage</div>';
    html += kv('sqlite path', esc(c.storage?.sqlite_path || 'â€”'));
    html += kv('chroma path', esc(c.storage?.chroma_path || 'â€”'));
    html += cfgToggle('log_conversations', 'Log conversations', c.storage?.log_conversations ?? true);

    // â”€â”€ Decision LLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Decision LLM</div>';
    html += cfgToggle('decision_llm_enabled', 'Enabled', c.decision_llm?.enabled ?? false);
    html += kv('model', esc(c.decision_llm?.model || 'â€”'));
    html += kv('timeout', `${c.decision_llm?.timeout || 5}s`);
    html += kv('max tokens', String(c.decision_llm?.max_tokens || 256));

    // â”€â”€ Operator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Operator</div>';
    html += kv('model', esc(c.operator?.model || 'â€”'));
    html += kv('max iterations', String(c.operator?.max_iterations || 10));
    html += kv('shell', badge(c.operator?.shell_enabled));

    // â”€â”€ Tools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Tools</div>';
    html += cfgToggle('tools_enabled', 'Tools master switch', c.tools?.enabled ?? false);
    const toolList = (t.tools || []);
    if (toolList.length) html += kv('registered', toolList.map(n=>`<span class="badge badge-ok">${esc(n)}</span>`).join(' '));
    // Individual tool toggles (informational â€” toggling requires config.yaml edit for now)
    if (c.tools?.web_search)  html += kv('web_search',  badge(c.tools.web_search.enabled));
    if (c.tools?.web_scraper) html += kv('web_scraper', badge(c.tools.web_scraper.enabled));
    if (c.tools?.calculator)  html += kv('calculator',  badge(c.tools.calculator?.enabled));
    if (c.tools?.datetime)    html += kv('datetime',    badge(c.tools.datetime?.enabled));
    if (c.tools?.system_info) html += kv('system_info', badge(c.tools.system_info?.enabled));
    if (c.tools?.memory)      html += kv('memory',      badge(c.tools.memory?.enabled));

    // â”€â”€ Feature Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Feature Flags</div>';

    // Cost tracking
    html += cfgToggle('cost_tracking_enabled', 'Cost tracking', c.cost_tracking?.enabled ?? false);
    html += `<div id="sub-cost_tracking_enabled" style="display:${c.cost_tracking?.enabled ? 'block' : 'none'};padding:4px 0 4px 24px;border-left:2px solid var(--bg-border);margin:2px 0 6px">`;
    html += cfgToggle('cost_track_openrouter', 'Track OpenRouter', c.cost_tracking?.track_openrouter ?? true);
    html += cfgToggle('cost_track_local',      'Track local (Ollama)', c.cost_tracking?.track_local ?? false);
    html += '</div>';

    // Orchestrator
    html += cfgToggle('orchestrator_enabled', 'Orchestrator', c.orchestrator?.enabled ?? false);
    html += `<div id="sub-orchestrator_enabled" style="display:${c.orchestrator?.enabled ? 'block' : 'none'};padding:4px 0 4px 24px;border-left:2px solid var(--bg-border);margin:2px 0 6px">`;
    html += cfgInput('orchestrator_max_parallel', 'Max parallel tasks', c.orchestrator?.max_parallel_tasks ?? 5, 'number');
    html += cfgInput('orchestrator_task_timeout', 'Task timeout (s)',   c.orchestrator?.task_timeout_seconds ?? 120, 'number');
    html += cfgInput('orchestrator_total_timeout','Total timeout (s)',  c.orchestrator?.total_timeout_seconds ?? 300, 'number');
    html += '</div>';

    // Conversation replay (no sub-options)
    html += cfgToggle('conversation_replay_enabled', 'Conversation replay', c.conversation_replay?.enabled ?? false);

    // Auto-summarization
    html += cfgToggle('auto_summarization_enabled', 'Auto-summarization', c.auto_summarization?.enabled ?? false);
    html += `<div id="sub-auto_summarization_enabled" style="display:${c.auto_summarization?.enabled ? 'block' : 'none'};padding:4px 0 4px 24px;border-left:2px solid var(--bg-border);margin:2px 0 6px">`;
    html += cfgInput('auto_token_budget',    'Token budget (trigger)',  c.auto_summarization?.token_budget ?? 3000, 'number');
    html += cfgInput('auto_summary_model',   'Summary model',           c.auto_summarization?.summary_model ?? '');
    html += cfgInput('auto_keep_last',       'Keep last N messages',    c.auto_summarization?.keep_last ?? 4, 'number');
    html += '</div>';

    // â”€â”€ Routing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Routing (session overrides)</div>';
    html += cfgSelect('force_route', 'Force route', c.routing?.force_route || '',
                      ['', 'simple', 'complex', 'code', 'large', 'fast']);
    html += kv('session TTL', `${c.routing?.session_ttl_seconds || 1800}s`);

    // â”€â”€ Backends â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Multi-Backend</div>';
    html += kv('enabled', badge(c.backends_enabled));
    (c.backends || []).forEach((b, i) => {
      html += kv(`backend ${i+1}`, `<span class="badge badge-lav">${esc(b.name||'?')}</span> ${esc(b.url||'')} <span class="badge">${esc(b.provider||'')}</span>`);
    });

    // â”€â”€ Model Advertising â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Model Advertising</div>';
    html += kv('mode', esc(c.model_advertising?.mode || 'â€”'));
    html += kv('prefix', esc(c.model_advertising?.prefix || 'â€”'));

    // â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Logging</div>';
    html += cfgSelect('log_level', 'Log level', c.logging?.level || 'INFO',
                      ['DEBUG', 'INFO', 'WARNING', 'ERROR']);
    html += kv('log file', esc(c.logging?.file || 'â€”'));
    html += kv('wiretap', esc(c.wiretap?.path || 'â€”'));

    // â”€â”€ Web UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Web UI</div>';
    html += cfgSelect('web_ui_palette', 'Palette theme', c.web_ui?.palette || 'default',
                      ['default','phosphor','cobalt','sakura','slate']);
    html += cfgToggle('web_ui_vi_mode', 'Vi mode', c.web_ui?.vi_mode ?? false);

    // â”€â”€ Voice / Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Voice / Audio</div>';
    html += cfgToggle('voice_enabled', 'Enable mic button / Push-to-talk (requires STT service)', c.web_ui?.voice_enabled ?? false);
    html += cfgInput('voice_hotkey', 'PTT hotkey (single key, e.g. v)', c.web_ui?.voice_hotkey || '');
    html += cfgInput('stt_url', 'STT service URL', c.voice?.stt_url || '', 'text', 'e.g. http://localhost:9000  (blank = use backend URL)');
    html += cfgToggle('tts_autoplay', 'Auto-play TTS after each assistant response', c.voice?.tts_autoplay ?? false);
    html += `<div id="sub-tts_autoplay" style="display:${c.voice?.tts_autoplay ? 'block' : 'none'};margin-left:16px;margin-top:4px;border-left:2px solid var(--bg-border);padding-left:10px">`;
    html += cfgInput('tts_url',   'TTS service URL', c.voice?.tts_url || '', 'text', 'e.g. http://localhost:8880  (blank = use backend URL)');
    html += cfgInput('tts_model', 'TTS model', c.voice?.tts_model || 'tts-1', 'text', 'tts-1 Â· kokoro Â· etc.');
    const ttsVoiceOptions = ['alloy','echo','fable','onyx','nova','shimmer','af','af_bella','af_sarah','am_adam','af_sky'];
    html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">` +
      `<label style="width:140px;font-size:12px;color:var(--muted)">TTS voice</label>` +
      `<input id="cfg-tts_voice" list="tts-voice-list" value="${esc(c.voice?.tts_voice || 'alloy')}" ` +
      `style="width:160px;background:var(--bg2);color:var(--fg);border:1px solid var(--border);border-radius:4px;padding:3px 6px;font-size:12px">` +
      `<datalist id="tts-voice-list">${ttsVoiceOptions.map(v=>`<option value="${esc(v)}">`).join('')}</datalist></div>`;
    html += cfgInput('tts_speed', 'Speed (0.25â€“4.0)', c.voice?.tts_speed ?? 1.0, 'number');
    html += `<div style="margin-top:6px;display:flex;gap:8px">` +
      `<button class="action-btn" onclick="testTTS()">â–¶ Test TTS</button>` +
      `<button class="action-btn" id="tts-stop-btn" style="display:none" onclick="stopTTS()">â–  Stop</button>` +
      `</div>`;
    html += `</div>`;

    // â”€â”€ Session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Session Overrides</div>';
    html += cfgInput('system_prompt_prefix', 'System prompt prefix', c.runtime?.system_prompt_prefix || '');

    // â”€â”€ System Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">System Context</div>';
    html += cfgToggle('system_context_enabled', 'Inject system_context.md into every request', c.system_context?.enabled ?? false);
    html += `<div id="sub-system_context_enabled" style="display:${c.system_context?.enabled ? 'block' : 'none'};margin-left:16px;margin-top:6px">`;
    html += `<div style="font-size:11px;color:var(--muted);margin-bottom:6px">Path: <code>${esc(c.system_context?.path || './system_context.md')}</code> â€” hot-reloaded on every request</div>`;
    html += `<textarea id="cfg-system-context-content" rows="6" style="width:100%;font-family:monospace;font-size:12px;background:var(--bg2);color:var(--fg);border:1px solid var(--border);border-radius:4px;padding:6px;resize:vertical;box-sizing:border-box" placeholder="You are a helpful assistant specialising in..."></textarea>`;
    html += `<div style="margin-top:4px;display:flex;gap:8px"><button class="action-btn" onclick="loadSystemContext()">â†“ Load current</button><button class="action-btn" onclick="saveSystemContext()">â†‘ Save context</button></div>`;
    html += '</div>';

    // â”€â”€ Generation Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    html += '<div class="section-header" style="margin-top:14px">Generation Parameters</div>';
    html += `<div style="font-size:11px;color:var(--muted);margin-bottom:8px">Override parameters injected into every proxied request. Leave blank to let the frontend decide. <strong>Force override</strong> overrides even frontend-set values.</div>`;
    html += cfgToggle('gen_force', 'Force override (override even frontend-set values)', c.generation?.force ?? false);
    const genNum = (k, label, val, step='any', min='', max='') =>
      `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">` +
      `<label style="width:140px;font-size:12px;color:var(--muted)">${label}</label>` +
      `<input id="cfg-${k}" type="number" step="${step}" ${min !== '' ? `min="${min}"` : ''} ${max !== '' ? `max="${max}"` : ''}` +
      ` value="${val ?? ''}" placeholder="unset" style="width:90px;background:var(--bg2);color:var(--fg);border:1px solid var(--border);border-radius:4px;padding:3px 6px;font-size:12px">` +
      `</div>`;
    html += genNum('gen_temperature',    'Temperature',     c.generation?.temperature,    '0.01', '0', '2');
    html += genNum('gen_top_p',          'Top P',           c.generation?.top_p,          '0.01', '0', '1');
    html += genNum('gen_top_k',          'Top K',           c.generation?.top_k,          '1',    '0');
    html += genNum('gen_num_ctx',        'Context window',  c.generation?.num_ctx,        '128',  '512');
    html += genNum('gen_repeat_penalty', 'Repeat penalty',  c.generation?.repeat_penalty, '0.01', '0');
    html += genNum('gen_max_tokens',     'Max tokens',      c.generation?.max_tokens,     '1',    '1');
    html += genNum('gen_seed',           'Seed',            c.generation?.seed,           '1',    '0');
    html += `<div style="margin-top:6px"><button class="action-btn" onclick="resetGenParams()" style="background:var(--warn,#554422);color:var(--fg)">âœ• Clear all generation params</button></div>`;

    document.getElementById('config-updated').textContent = 'updated ' + new Date().toLocaleTimeString();
    el.innerHTML = html;

    // Wire toggle labels + expand/collapse sub-options
    const toggleIds = [
      'log_conversations','decision_llm_enabled','tools_enabled',
      'cost_tracking_enabled','cost_track_openrouter','cost_track_local',
      'orchestrator_enabled',
      'conversation_replay_enabled','auto_summarization_enabled',
      'web_ui_vi_mode','voice_enabled','tts_autoplay','system_context_enabled','gen_force',
    ];
    toggleIds.forEach(id => {
      const cb = document.getElementById(`cfg-${id}`);
      const lbl = document.getElementById(`cfg-${id}-lbl`);
      if (cb && lbl) cb.addEventListener('change', () => { lbl.textContent = cb.checked ? 'enabled' : 'disabled'; });
    });
    // Expand sub-options when parent feature flag is toggled
    ['cost_tracking_enabled','orchestrator_enabled',
     'auto_summarization_enabled','system_context_enabled','tts_autoplay'].forEach(id => {
      const cb = document.getElementById(`cfg-${id}`);
      const sub = document.getElementById(`sub-${id}`);
      if (cb && sub) {
        cb.addEventListener('change', () => {
          sub.style.display = cb.checked ? 'block' : 'none';
          if (id === 'system_context_enabled' && cb.checked) loadSystemContext();
        });
      }
    });
    // Auto-load context if already enabled
    if (c.system_context?.enabled) loadSystemContext();

  } catch(e) {
    el.innerHTML = `<div class="error-box">Failed to load config: ${esc(e.message)}</div>`;
  }
}

async function saveConfig() {
  const status = document.getElementById('cfg-save-status');
  if (status) status.textContent = 'savingâ€¦';

  // Collect all editable fields
  const getChecked = id => { const el = document.getElementById(`cfg-${id}`); return el ? el.checked : null; };
  const getVal = id => { const el = document.getElementById(`cfg-${id}`); return el ? (el.value ?? null) : null; };

  const payload = {};
  const bools = [
    'log_conversations','decision_llm_enabled','tools_enabled',
    'cost_tracking_enabled','cost_track_openrouter','cost_track_local',
    'orchestrator_enabled',
    'conversation_replay_enabled','auto_summarization_enabled',
    'web_ui_vi_mode','voice_enabled','tts_autoplay','system_context_enabled','gen_force',
  ];
  const strings = [
    'default_model','force_route','log_level','web_ui_palette',
    'voice_hotkey','system_prompt_prefix','auto_summary_model',
    'stt_url','tts_url','tts_model','tts_voice',
  ];
  const numbers = [
    'orchestrator_max_parallel','orchestrator_task_timeout','orchestrator_total_timeout',
    'auto_token_budget','auto_keep_last',
    'gen_temperature','gen_top_p','gen_top_k','gen_num_ctx',
    'gen_repeat_penalty','gen_max_tokens','gen_seed',
    'tts_speed',
  ];
  bools.forEach(k => { const v = getChecked(k); if (v !== null) payload[k] = v; });
  strings.forEach(k => { const v = getVal(k); if (v !== null) payload[k] = v; });
  numbers.forEach(k => { const el = document.getElementById(`cfg-${k}`); if (el && el.value !== '') payload[k] = parseFloat(el.value); });

  try {
    const d = await api('/api/v1/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    // Apply immediately in the UI where possible
    if ('web_ui_palette' in payload) applyPalette(payload.web_ui_palette);
    if ('web_ui_vi_mode' in payload) {
      setViToggleState(payload.web_ui_vi_mode);
      if (payload.web_ui_vi_mode) injectViMode(); else removeViMode?.();
    }
    if ('voice_enabled' in payload) {
      if (payload.voice_enabled) enableVoiceUI(payload.voice_hotkey || '');
      else { const btn = document.getElementById('mic-btn'); if (btn) btn.style.display = 'none'; }
    }
    // Re-fetch config to pick up TTS changes live
    try { const fresh = await api('/api/v1/config'); updateTTSConfig(fresh); } catch {}

    if (status) status.textContent = `âœ“ saved (${d.saved?.length || 0} keys)`;
    setTimeout(() => { if (status) status.textContent = ''; }, 3000);
  } catch(e) {
    if (e.status === 404) {
      if (status) status.textContent = 'âœ— Config save endpoint not found â€” rebuild the container with the latest main.py';
    } else {
      if (status) status.textContent = `âœ— ${esc(e.message)}`;
    }
  }
}


async function loadSystemContext() {
  const ta = document.getElementById('cfg-system-context-content');
  if (!ta) return;
  try {
    const d = await api('/api/v1/system-context');
    ta.value = d.content || '';
  } catch(e) {
    ta.value = '';
    console.warn('Failed to load system context:', e);
  }
}

async function saveSystemContext() {
  const ta = document.getElementById('cfg-system-context-content');
  const status = document.getElementById('cfg-save-status');
  if (!ta) return;
  try {
    await api('/api/v1/system-context', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: ta.value }),
    });
    if (status) status.textContent = 'âœ“ system_context.md saved';
    setTimeout(() => { if (status) status.textContent = ''; }, 3000);
  } catch(e) {
    if (status) status.textContent = `âœ— ${esc(e.message)}`;
  }
}

async function resetGenParams() {
  const status = document.getElementById('cfg-save-status');
  try {
    await api('/api/v1/generation-params/reset', { method: 'POST' });
    if (status) status.textContent = 'âœ“ Generation params cleared';
    setTimeout(() => { loadConfig(); if (status) status.textContent = ''; }, 1000);
  } catch(e) {
    if (status) status.textContent = `âœ— ${esc(e.message)}`;
  }
}

async function buildCentroids() {
  const btn = document.getElementById('centroids-btn');
  const status = document.getElementById('cfg-save-status');
  if (btn) btn.disabled = true;
  if (status) status.textContent = 'âš™ Building centroidsâ€¦ (may take 10-30s)';
  try {
    const d = await api('/api/v1/build-centroids', { method: 'POST' });
    if (status) status.textContent = d.success ? 'âœ“ Centroids built' : `âœ— ${d.error}`;
  } catch(e) {
    if (status) status.textContent = `âœ— ${esc(e.message)}`;
  } finally {
    if (btn) btn.disabled = false;
    setTimeout(() => { if (status) status.textContent = ''; }, 5000);
  }
}

loadDashboard();
loadModels();

// Restore tap filters from localStorage
try {
  const savedRole = localStorage.getItem('bb_tap_role');

  const savedDir  = localStorage.getItem('bb_tap_dir');
  const savedN    = localStorage.getItem('bb_tap_n');
  if (savedRole !== null) document.getElementById('tap-role').value = savedRole;
  if (savedDir  !== null) document.getElementById('tap-dir').value  = savedDir;
  if (savedN    !== null) document.getElementById('tap-n').value    = savedN;
} catch {}

// Initialize multi-pane chat (creates first pane, no history restore needed â€” per-pane history is in memory only)
initChatPanes();

// Bootstrap vi mode and palette from runtime config in a single fetch
(async function initWebUi() {
  try {
    const d = await api('/api/v1/config');

    // Vi mode
    const viEnabled = d.web_ui?.vi_mode === true;
    setViToggleState(viEnabled);
    if (viEnabled) injectViMode();

    // Palette
    const palette = d.web_ui?.palette || 'default';
    if (palette !== 'default') applyPalette(palette);

    // Voice PTT
    if (d.web_ui?.voice_enabled) {
      enableVoiceUI(d.web_ui?.voice_hotkey || '');
    }

    // TTS autoplay config
    updateTTSConfig(d);

  } catch {}

  // Unlock AudioContext on first user interaction (browser autoplay policy)
  document.addEventListener('click', () => {
    if (window.AudioContext || window.webkitAudioContext) _initAudioCtx();
  }, { once: true });
})();
</script>
</body>
</html>
